<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Writing solvers · GeoStats.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GeoStats.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../data_manipulation/">Manipulating data</a></li><li><a class="toctext" href="../problem_definition/">Defining problems</a></li><li><a class="toctext" href="../solution_plotting/">Plotting solutions</a></li></ul></li><li><a class="toctext" href="../tutorials/">Tutorials</a></li><li><span class="toctext">Reference guide</span><ul><li><a class="toctext" href="../problems_and_solvers/">Problems</a></li><li><a class="toctext" href="../data/">Data</a></li><li><a class="toctext" href="../domains/">Domains</a></li><li><span class="toctext">Variography</span><ul><li><a class="toctext" href="../empirical_variograms/">Empirical variograms</a></li><li><a class="toctext" href="../theoretical_variograms/">Theoretical variograms</a></li><li><a class="toctext" href="../fitting_variograms/">Fitting variograms</a></li></ul></li><li><a class="toctext" href="../estimators/">Kriging estimators</a></li><li><a class="toctext" href="../comparisons/">Solver comparisons</a></li><li><a class="toctext" href="../statistics/">Spatial statistics</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li></ul></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../about/community/">Community</a></li><li><a class="toctext" href="../about/license/">License</a></li><li><a class="toctext" href="../about/citing/">Citing</a></li></ul></li><li><span class="toctext">Developer guide</span><ul><li><a class="toctext" href="../developer_basics/">The basics</a></li><li><a class="toctext" href="../developer_tools/">Developer tools</a></li><li class="current"><a class="toctext" href>Writing solvers</a><ul class="internal"><li><a class="toctext" href="#Estimation-solver-example-1">Estimation solver example</a></li><li><a class="toctext" href="#Simulation-solver-example-1">Simulation solver example</a></li><li><a class="toctext" href="#Learning-solver-example-1">Learning solver example</a></li></ul></li></ul></li><li><a class="toctext" href="../links/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Developer guide</li><li><a href>Writing solvers</a></li></ul><a class="edit-page" href="https://github.com/juliohm/GeoStats.jl/blob/master/docs/src/developer_example.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Writing solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Writing-solvers-1" href="#Writing-solvers-1">Writing solvers</a></h1><p>Below are examples of solvers written with the framework.</p><h2><a class="nav-anchor" id="Estimation-solver-example-1" href="#Estimation-solver-example-1">Estimation solver example</a></h2><p>An estimation solver that, for each location of the domain, assigns the 2-norm of the coordinates as the mean and the ∞-norm as the variance.</p><pre><code class="language-julia">using GeoStatsBase
using LinearAlgebra: norm

# implement method for new solver
import GeoStatsBase: solve

@estimsolver NormSolver begin
  @param pmean = 2
  @param pvar  = Inf
end

function solve(problem::EstimationProblem, solver::NormSolver)
  pdomain = domain(problem)

  # results for each variable
  μs = []; σs = []

  for (var,V) in variables(problem)
    # get user parameters
    if var in keys(solver.params)
      varparams = solver.params[var]
    else
      varparams = NormSolverParam()
    end

    # allocate memory for result
    varμ = Vector{V}(undef, npoints(pdomain))
    varσ = Vector{V}(undef, npoints(pdomain))

    for location in LinearPath(pdomain)
      x = coordinates(pdomain, location)

      varμ[location] = norm(x, varparams.pmean)
      varσ[location] = norm(x, varparams.pvar)
    end

    push!(μs, var =&gt; varμ)
    push!(σs, var =&gt; varσ)
  end

  EstimationSolution(pdomain, Dict(μs), Dict(σs))
end;</code></pre><pre><code class="language-none">solve (generic function with 6 methods)</code></pre><p>We can test the newly defined solver on an estimation problem:</p><pre><code class="language-julia">using GeoStats
using Plots

# dummy spatial data with a single point and no value
sdata   = PointSetData(Dict(:z =&gt; [NaN]), reshape([0.,0.], 2, 1))

# estimate on a regular grid
sdomain = RegularGrid{Float64}(100, 100)

# the problem to be solved
problem = EstimationProblem(sdata, sdomain, :z)

# our new solver
solver = NormSolver()

solution = solve(problem, solver)

contourf(solution)</code></pre><p><img src="../images/normsolver1.png" alt/></p><p>And assess the behavior of different parameters:</p><pre><code class="language-julia">solver = NormSolver(:z =&gt; (pmean=1,pvar=3))

solution = solve(problem, solver)

contourf(solution)</code></pre><p><img src="../images/normsolver2.png" alt/></p><h2><a class="nav-anchor" id="Simulation-solver-example-1" href="#Simulation-solver-example-1">Simulation solver example</a></h2><p>A simulation solver that, for each location of the domain, assigns a random sample from a Gaussian distribution.</p><pre><code class="language-julia">using GeoStatsBase

# implement method for new solver
import GeoStatsBase: solve_single

@simsolver RandSolver begin
  @param mean = 0
  @param var  = 1
end

function solve_single(problem::SimulationProblem, var::Symbol,
                      solver::RandSolver, preproc)
  pdomain = domain(problem)

  # retrieve solver parameters
  varparams = solver.params[var]
  μ, σ² = varparams.mean, varparams.var

  # i.i.d. samples ~ Normal(0,1)
  z = rand(npoints(pdomain))

  # rescale and return
  μ .+ sqrt(σ²) .* z
end;</code></pre><pre><code class="language-none">solve_single (generic function with 4 methods)</code></pre><p>We can test the newly defined solver in a simulation problem:</p><pre><code class="language-julia">using GeoStats
using Plots

# simulate on a regular grid
sdomain = RegularGrid{Float64}(100, 100)

# the problem to be solved
problem = SimulationProblem(sdomain, :z =&gt; Float64, 3)

# our new solver
solver = RandSolver(:z =&gt; (mean=10.,var=10.))

solution = solve(problem, solver)

heatmap(solution)</code></pre><p><img src="../images/randsolver1.png" alt/></p><p>Note, however, that we did not define the <code>preprocess</code> function for the solver. This function can be used to avoid recalculations for each realization, and to set default parameters for variables that are not explicitly set by users in the solver constructor:</p><pre><code class="language-julia">import GeoStatsBase: preprocess

function preprocess(problem::SimulationProblem, solver::RandSolver)
  # result of preprocessing
  preproc = Dict{Symbol,NamedTuple}()

  for (varname, V) in variables(problem)
    if varname ∈ keys(solver.params)
      # get user parameters
      varparams = solver.params[varname]
    else
      # set default parameters
      varparams = RandSolverParam()
    end

    preproc[varname] = (mean=varparams.mean, var=varparams.var)
  end

  preproc
end;</code></pre><pre><code class="language-none">preprocess (generic function with 5 methods)</code></pre><p>We can call the <code>preprocess</code> function on problems with multiple variables to check that the solver is producing default values for variables other than the one passed during construction:</p><pre><code class="language-julia">problem = SimulationProblem(sdomain, (:z=&gt;Float64, :w=&gt;Float64), 3)

preprocess(problem, solver)</code></pre><pre><code class="language-none">Dict{Symbol,NamedTuple} with 2 entries:
  :w =&gt; (mean = 0, var = 1)
  :z =&gt; (mean = 10.0, var = 10.0)</code></pre><p>This <code>preproc</code> output is passed by GeoStats.jl as the last argument to the <code>solve_single</code> function, which could be reimplemented as follows:</p><pre><code class="language-julia">function solve_single(problem::SimulationProblem, var::Symbol,
                      solver::RandSolver, preproc)
  pdomain = domain(problem)

  # retrieve solver parameters
  μ, σ² = preproc[var]

  # i.i.d. samples ~ Normal(0,1)
  z = rand(npoints(pdomain))

  # rescale and return
  μ .+ sqrt(σ²) .* z
end;</code></pre><pre><code class="language-none">solve_single (generic function with 4 methods)</code></pre><h2><a class="nav-anchor" id="Learning-solver-example-1" href="#Learning-solver-example-1">Learning solver example</a></h2><p>TODO</p><footer><hr/><a class="previous" href="../developer_tools/"><span class="direction">Previous</span><span class="title">Developer tools</span></a><a class="next" href="../links/"><span class="direction">Next</span><span class="title">Index</span></a></footer></article></body></html>
