<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver examples · GeoStats.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GeoStats.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">GeoStats.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../workflow/">Basic workflow</a></li><li><span class="tocitem">Reference guide</span><ul><li><a class="tocitem" href="../../data/">Data</a></li><li><a class="tocitem" href="../../domains/">Domains</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Operations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../operations/partitioning/">Partitioning</a></li><li><a class="tocitem" href="../../operations/sampling/">Sampling</a></li><li><a class="tocitem" href="../../operations/weighting/">Weighting</a></li><li><a class="tocitem" href="../../operations/filtering/">Filtering</a></li><li><a class="tocitem" href="../../operations/joining/">Joining</a></li><li><a class="tocitem" href="../../operations/searching/">Searching</a></li><li><a class="tocitem" href="../../operations/covering/">Covering</a></li><li><a class="tocitem" href="../../operations/discretizing/">Discretizing</a></li></ul></li><li><a class="tocitem" href="../../statistics/">Statistics</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../solvers/">Solvers</a></li><li><a class="tocitem" href="../../validation/">Validation</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Variography</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../variography/empirical/">Empirical variograms</a></li><li><a class="tocitem" href="../../variography/theoretical/">Theoretical variograms</a></li><li><a class="tocitem" href="../../variography/fitting/">Fitting variograms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Kriging</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../kriging/estimators/">Estimators</a></li><li><a class="tocitem" href="../../kriging/solver/">Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-10" type="checkbox"/><label class="tocitem" for="menuitem-3-10"><span class="docs-label">Point Patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pointpatterns/pointprocs/">Processes</a></li><li><a class="tocitem" href="../../pointpatterns/regions/">Regions</a></li><li><a class="tocitem" href="../../pointpatterns/pointops/">Operations</a></li></ul></li><li><a class="tocitem" href="../../plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Developer guide</span><ul><li><a class="tocitem" href="../basics/">The basics</a></li><li class="is-active"><a class="tocitem" href>Solver examples</a><ul class="internal"><li><a class="tocitem" href="#Estimation-1"><span>Estimation</span></a></li><li><a class="tocitem" href="#Simulation-1"><span>Simulation</span></a></li><li><a class="tocitem" href="#Learning-1"><span>Learning</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../related/">Related projects</a></li><li><span class="tocitem">About</span><ul><li><a class="tocitem" href="../../about/community/">Community</a></li><li><a class="tocitem" href="../../about/license/">License</a></li><li><a class="tocitem" href="../../about/citing/">Citing</a></li></ul></li><li><a class="tocitem" href="../../links/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer guide</a></li><li class="is-active"><a href>Solver examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaEarth/GeoStats.jl/blob/master/docs/src/devguide/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver-examples-1"><a class="docs-heading-anchor" href="#Solver-examples-1">Solver examples</a><a class="docs-heading-anchor-permalink" href="#Solver-examples-1" title="Permalink"></a></h1><p>Below are examples of solvers written with the framework.</p><h2 id="Estimation-1"><a class="docs-heading-anchor" href="#Estimation-1">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-1" title="Permalink"></a></h2><p>An estimation solver that, for each location of the domain, assigns the 2-norm of the coordinates as the mean and the ∞-norm as the variance.</p><pre><code class="language-julia">using GeoStatsBase
using LinearAlgebra: norm

# implement method for new solver
import GeoStatsBase: solve

@estimsolver NormSolver begin
  @param pmean = 2
  @param pvar  = Inf
end

function solve(problem::EstimationProblem, solver::NormSolver)
  pdomain = domain(problem)

  # results for each variable
  μs = []; σs = []

  for covars in covariables(problem, solver)
    for var in covars.names
      # get user parameters
      varparams = covars.params[(var,)]

      # get variable type
      V = variables(problem)[var]

      # allocate memory for result
      varμ = Vector{V}(undef, npoints(pdomain))
      varσ = Vector{V}(undef, npoints(pdomain))

      for location in LinearPath(pdomain)
        x = coordinates(pdomain, location)

        varμ[location] = norm(x, varparams.pmean)
        varσ[location] = norm(x, varparams.pvar)
      end

      push!(μs, var =&gt; varμ)
      push!(σs, var =&gt; varσ)
    end
  end

  EstimationSolution(pdomain, Dict(μs), Dict(σs))
end;</code></pre><pre><code class="language-none">solve (generic function with 6 methods)</code></pre><p>We can test the newly defined solver on an estimation problem:</p><pre><code class="language-julia">using GeoStats
using Plots

# dummy spatial data with a single point and no value
sdata   = PointSetData(OrderedDict(:z =&gt; [NaN]), reshape([0.,0.], 2, 1))

# estimate on a regular grid
sdomain = RegularGrid{Float64}(100, 100)

# the problem to be solved
problem = EstimationProblem(sdata, sdomain, :z)

# our new solver
solver = NormSolver()

solution = solve(problem, solver)

contourf(solution)</code></pre><p><img src="../../images/normsolver1.png" alt/></p><p>And assess the behavior of different parameters:</p><pre><code class="language-julia">solver = NormSolver(:z =&gt; (pmean=1,pvar=3))

solution = solve(problem, solver)

contourf(solution)</code></pre><p><img src="../../images/normsolver2.svg" alt/></p><h2 id="Simulation-1"><a class="docs-heading-anchor" href="#Simulation-1">Simulation</a><a class="docs-heading-anchor-permalink" href="#Simulation-1" title="Permalink"></a></h2><p>A simulation solver that, for each location of the domain, assigns a random sample from a Gaussian distribution.</p><pre><code class="language-julia">using GeoStatsBase

# implement method for new solver
import GeoStatsBase: solvesingle

@simsolver RandSolver begin
  @param mean = 0
  @param var  = 1
end

function solvesingle(problem::SimulationProblem, covars::NamedTuple,
                     solver::RandSolver, preproc)
  pdomain = domain(problem)

  real4var = map(covars.names) do var
    # retrieve solver parameters
    varparams = covars.params[(var,)]
    μ, σ² = varparams.mean, varparams.var

    # i.i.d. samples ~ Normal(0,1)
    z = rand(npoints(pdomain))

    # rescale and return
    var =&gt; μ .+ sqrt(σ²) .* z
  end

  Dict(real4var)
end;</code></pre><pre><code class="language-none">solvesingle (generic function with 4 methods)</code></pre><p>We can test the newly defined solver in a simulation problem:</p><pre><code class="language-julia">using GeoStats
using Plots

# simulate on a regular grid
sdomain = RegularGrid{Float64}(100, 100)

# the problem to be solved
problem = SimulationProblem(sdomain, :z =&gt; Float64, 3)

# our new solver
solver = RandSolver(:z =&gt; (mean=10.,var=10.))

solution = solve(problem, solver)

heatmap(solution)</code></pre><p><img src="../../images/randsolver1.svg" alt/></p><p>Note, however, that we did not define the <code>preprocess</code> function for the solver. This function can be used to avoid recalculations for each realization, and to set default parameters for variables that are not explicitly set by users in the solver constructor:</p><pre><code class="language-julia">import GeoStatsBase: preprocess

function preprocess(problem::SimulationProblem, solver::RandSolver)
  preproc = Dict()
  for covars in covariables(problem, solver)
    for varname in covars.names
      varparams = covars.params[(varname,)]
      preproc[varname] = (mean=varparams.mean, var=varparams.var)
    end
  end

  preproc
end;</code></pre><pre><code class="language-none">preprocess (generic function with 5 methods)</code></pre><p>We can call the <code>preprocess</code> function on problems with multiple variables to check that the solver is producing default values for variables other than the one passed during construction:</p><pre><code class="language-julia">problem = SimulationProblem(sdomain, (:z=&gt;Float64, :w=&gt;Float64), 3)

preprocess(problem, solver)</code></pre><pre><code class="language-none">Dict{Any,Any} with 2 entries:
  :w =&gt; (mean = 0, var = 1)
  :z =&gt; (mean = 10.0, var = 10.0)</code></pre><p>This <code>preproc</code> output is passed by GeoStats.jl as the last argument to the <code>solvesingle</code> function, which could be reimplemented as follows:</p><pre><code class="language-julia">function solvesingle(problem::SimulationProblem, covars::NamedTuple,
                     solver::RandSolver, preproc)
  pdomain = domain(problem)

  real4var = map(covars.names) do var
    # retrieve solver parameters
    μ, σ² = preproc[var]

    # i.i.d. samples ~ Normal(0,1)
    z = rand(npoints(pdomain))

    # rescale and return
    var =&gt; μ .+ sqrt(σ²) .* z
  end

  Dict(real4var)
end;</code></pre><pre><code class="language-none">solvesingle (generic function with 4 methods)</code></pre><h2 id="Learning-1"><a class="docs-heading-anchor" href="#Learning-1">Learning</a><a class="docs-heading-anchor-permalink" href="#Learning-1" title="Permalink"></a></h2><p>A learning solver that clusters data into super pixels:</p><pre><code class="language-julia">using GeoStatsBase

# implement method for new solver
import GeoStatsBase: solvesingle

struct SLICSolver &lt;: AbstractLearningSolver
  k::Int # approximate number of super pixels
  m::Float64 # SLIC tradeoff parameter
end

function solve(problem::LearningProblem, solver::SLICSolver)
  @assert task(problem) isa ClusteringTask &quot;invalid problem&quot;

  # retrieve problem info
  ptask  = task(problem)
  feats  = collect(features(ptask))
  tdata  = targetdata(problem)
  output = outputvars(ptask)[1]

  # find super pixels
  slic = SLICPartitioner(solver.k, solver.m, vars=feats)
  part = partition(tdata, slic)

  # label for each point in target data
  labels = Vector{Int}(undef, npoints(tdata))
  for (i, inds) in enumerate(subsets(part))
    labels[inds] .= i
  end

  # return learning solution
  LearningSolution(domain(tdata), OrderedDict(output =&gt; labels))
end;</code></pre><pre><code class="language-none">solve (generic function with 1 method)</code></pre><p>We can test the newly defined solver in a learning problem:</p><pre><code class="language-julia">using GeoStats
using Plots

Z = [10sin(i/10) + j for i in 1:100, j in 1:100]

Ω = RegularGridData{Float64}(OrderedDict(:Z=&gt;Z))

t = ClusteringTask(:Z, :SUPERPIXEL)

p = LearningProblem(Ω, Ω, t)

s = solve(p, SLICSolver(50, 0.01))

plot(plot(Ω), plot(s, c=:viridis))</code></pre><p><img src="../../images/slicsolver.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« The basics</a><a class="docs-footer-nextpage" href="../../contributing/">Contributing »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 26 April 2020 23:24">Sunday 26 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
