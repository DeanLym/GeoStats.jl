var documenterSearchIndex = {"docs":
[{"location":"about/community/#","page":"Community","title":"Community","text":"Everyone is welcome to join our community in our gitter channel.","category":"page"},{"location":"about/community/#","page":"Community","title":"Community","text":"(Image: gitter)","category":"page"},{"location":"fitting_variograms/#Fitting-variograms-1","page":"Fitting variograms","title":"Fitting variograms","text":"","category":"section"},{"location":"fitting_variograms/#","page":"Fitting variograms","title":"Fitting variograms","text":"Fitting theoretical variograms to empirical observations is an important preprocessing step to ensure valid mathematical models of spatial continuity. Given an empirical variogram, the fit function can be used to perform the fit:","category":"page"},{"location":"fitting_variograms/#","page":"Fitting variograms","title":"Fitting variograms","text":"fit(::Type{V}, ::EmpiricalVariogram, ::WeightedLeastSquares) where {V<:Variogram}","category":"page"},{"location":"fitting_variograms/#StatsBase.fit-Union{Tuple{V}, Tuple{Type{V},EmpiricalVariogram,WeightedLeastSquares}} where V<:Variogram","page":"Fitting variograms","title":"StatsBase.fit","text":"fit(V, γ, [algo])\n\nFit theoretical variogram type V to empirical variogram γ using algorithm algo. Default algorithm is WeightedLeastSquares.\n\n\n\n\n\n","category":"method"},{"location":"fitting_variograms/#","page":"Fitting variograms","title":"Fitting variograms","text":"Currently the following fitting methods are implemented:","category":"page"},{"location":"fitting_variograms/#Weighted-least-squares-1","page":"Fitting variograms","title":"Weighted least squares","text":"","category":"section"},{"location":"fitting_variograms/#","page":"Fitting variograms","title":"Fitting variograms","text":"WeightedLeastSquares","category":"page"},{"location":"fitting_variograms/#Variography.WeightedLeastSquares","page":"Fitting variograms","title":"Variography.WeightedLeastSquares","text":"WeightedLeastSquares()\nWeightedLeastSquares(weightfun)\n\nFit theoretical variogram using weighted least squares with weighting function weightfun (e.g. h -> 1/h). If not weighting function is provided, bin counts of empirical variogram are normalized and used as weights.\n\n\n\n\n\n","category":"type"},{"location":"devguide/#Developer-guide-1","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"This guide provides an overview of the spatial problems and solution types defined in the framework. After reading this document, you should be able to write your own geostatistical solvers, and enjoy a large set of features for free, including distributed parallel execution, a suite of meta algorithms, and various plot recipes. If you have any questions, please don't hesitate to ask in our gitter channel.","category":"page"},{"location":"devguide/#The-basics-1","page":"Developer guide","title":"The basics","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Currently, there are three types of spatial problems defined in the framework:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"EstimationProblem\nSimulationProblem\nLearningProblem","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"For each problem type, there is a corresponding solution type:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"EstimationSolution\nSimulationSolution\nLearningSolution","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Any EstimationSolver in the framework returns an EstimationSolution, which consists of the domain of the EstimationProblem plus two dictionaries: mdict mapping the variable names (a Symbol) of the problem to mean values, and vdict mapping the same variable names to variance values:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"EstimationSolution(domain, mdict, vdict)","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Any SimulationSolver in the framework returns a SimulationSolution, which consists of the domain of the SimulationProblem plus a dictionary rdict mapping the variable names (a Symbol) of the problem to a vector of (flattened) realizations:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"SimulationSolution(domain, rdict)","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Any LearningSolver in the framework returns a LearningSolution, which consits of the target domain of the LearningProblem plus a dictionary dict mapping variable names (a Symbol) of the problem to learned values:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"LearningSolution(domain, dict)","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"These definitions are implemented in the GeoStatsBase.jl package alongside other important conceptual components of the project.","category":"page"},{"location":"devguide/#Writing-a-solver-1","page":"Developer guide","title":"Writing a solver","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"The task of writing a solver for a spatial problem as defined consists of writing a simple function in Julia that takes the problem as input and returns the solution. In this section, an estimation solver is written that is not very useful (it fills the domain with random numbers), but that illustrates the development process.","category":"page"},{"location":"devguide/#Create-the-package-1","page":"Developer guide","title":"Create the package","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Install the PkgTemplates.jl package and create a new project:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using PkgTemplates\n\ngenerate_interactive(\"MySolver\")","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"This command will create a folder named ~/user/.julia/vx.y/MySolver with all the files that are necessary to load the new package:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using MySolver","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Choose a license for your solver. If you don't have major restrictions, I suggest using the ISC license. This license is equivalent to the MIT and BSD 2-Clause licenses, plus it eliminates unncessary language. Try to choose a permissive license so that your solver can be used, and improved by private companies.","category":"page"},{"location":"devguide/#Import-GeoStatsBase-1","page":"Developer guide","title":"Import GeoStatsBase","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"After the package is created, open the main source file MySolver.jl and add the following line:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStatsBase\nimport GeoStatsBase: solve","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"These lines bring all the symbols defined in GeoStatsBase into scope, and tell Julia that the method solve will be specialized for the new solver. Next, give your solver a name:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"struct MyCoolSolver <: AbstractEstimationSolver\n  # optional parameters go here\nend","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"and export it so that it becomes available to users of your package:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"export MyCoolSolver","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"At this point, the MySolver.jl file should have the following content:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"module MySolver\n\nusing GeoStatsBase\nimport GeoStatsBase: solve\n\nexport MyCoolSolver\n\nstruct MyCoolSolver <: AbstractEstimationSolver\n  # optional parameters go here\nend\n\nend # module","category":"page"},{"location":"devguide/#Write-the-algorithm-1","page":"Developer guide","title":"Write the algorithm","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Now that your solver type is defined, write your algorithm. Write a function called solve that takes an estimation problem and your solver, and returns an estimation solution:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"function solve(problem::EstimationProblem, solver::MyCoolSolver)\n  pdomain = domain(problem)\n\n  mean = Dict{Symbol,Vector}()\n  variance = Dict{Symbol,Vector}()\n\n  for (var,V) in variables(problem)\n    push!(mean, var => rand(npoints(pdomain)))\n    push!(variance, var => rand(npoints(pdomain)))\n  end\n\n  EstimationSolution(pdomain, mean, variance)\nend","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Paste this function somewhere in your package, and you are all set.","category":"page"},{"location":"devguide/#Test-the-solver-1","page":"Developer guide","title":"Test the solver","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"To test your new solver, load the GeoStats.jl package and solve a simple problem:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStats\nusing MySolver\n\nsdata    = readgeotable(\"somedata.csv\", coordnames=[:x,:y])\nsdomain  = RegularGrid{Float64}(100, 100)\nproblem  = EstimationProblem(sdata, sdomain, :value)\n\nsolution = solve(problem, MyCoolSolver())\n\nplot(solution)","category":"page"},{"location":"devguide/#Writing-simulation-solvers-1","page":"Developer guide","title":"Writing simulation solvers","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"The process of writing a simulation solver is very similar, but there is an alternative function to solve called solvesingle that is preferred. The function solvesingle takes a simulation problem, one of the variables to be simulated, a solver, and a preprocessed input, and returns a vector with the simulation results:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"function solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::MySimSolver, preproc)\n  # retrieve problem info\n  pdata = data(problem)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # output is a single realization for each covariable\n    real = Vector{V}(undef, npoints(pdomain))\n\n    # fill realization with hard data\n    for (loc, datloc) in datamap(problem, var)\n      real[loc] = pdata[datloc,var]\n    end\n\n    # algorithm goes here\n    # ...\n\n    var => real\n  end\n\n  Dict(real4var)\nend","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"This function is preferred over solve if your algorithm is the same for every single realization (the algorithm is only a function of the random seed). In this case, GeoStats.jl will provide an implementation of solve for you that calls solvesingle in parallel.","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"The argument preproc is ignored unless the function preprocess is also defined for the solver. The function takes a simulation problem and a solver, and returns an arbitrary object with preprocessed data:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"preprocess(problem::SimulationProblem, solver::MySimSolver) = nothing","category":"page"},{"location":"devguide/#Writing-learning-solvers-1","page":"Developer guide","title":"Writing learning solvers","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Similar to the other cases, writing a LearningSolver compatible with the framework consists of writing a simple Julia function that takes the LearningProblem as input along with the solver, and returns a LearningSolution.","category":"page"},{"location":"devguide/#Solver-examples-1","page":"Developer guide","title":"Solver examples","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Below are examples of solvers written with the framework.","category":"page"},{"location":"devguide/#Estimation-solver-example-1","page":"Developer guide","title":"Estimation solver example","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"An estimation solver that, for each location of the domain, assigns the 2-norm of the coordinates as the mean and the ∞-norm as the variance.","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStatsBase\nusing LinearAlgebra: norm\n\n# implement method for new solver\nimport GeoStatsBase: solve\n\n@estimsolver NormSolver begin\n  @param pmean = 2\n  @param pvar  = Inf\nend\n\nfunction solve(problem::EstimationProblem, solver::NormSolver)\n  pdomain = domain(problem)\n\n  # results for each variable\n  μs = []; σs = []\n\n  for covars in covariables(problem, solver)\n    for var in covars.names\n      # get user parameters\n      varparams = covars.params[(var,)]\n\n      # get variable type\n      V = variables(problem)[var]\n\n      # allocate memory for result\n      varμ = Vector{V}(undef, npoints(pdomain))\n      varσ = Vector{V}(undef, npoints(pdomain))\n\n      for location in LinearPath(pdomain)\n        x = coordinates(pdomain, location)\n\n        varμ[location] = norm(x, varparams.pmean)\n        varσ[location] = norm(x, varparams.pvar)\n      end\n\n      push!(μs, var => varμ)\n      push!(σs, var => varσ)\n    end\n  end\n\n  EstimationSolution(pdomain, Dict(μs), Dict(σs))\nend;","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"We can test the newly defined solver on an estimation problem:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStats\nusing Plots\ngr(size=(900,400)) # hide\n\n# dummy spatial data with a single point and no value\nsdata   = PointSetData(OrderedDict(:z => [NaN]), reshape([0.,0.], 2, 1))\n\n# estimate on a regular grid\nsdomain = RegularGrid{Float64}(100, 100)\n\n# the problem to be solved\nproblem = EstimationProblem(sdata, sdomain, :z)\n\n# our new solver\nsolver = NormSolver()\n\nsolution = solve(problem, solver)\n\ncontourf(solution)\npng(\"images/normsolver1.png\") # hide","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"(Image: )","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"And assess the behavior of different parameters:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"solver = NormSolver(:z => (pmean=1,pvar=3))\n\nsolution = solve(problem, solver)\n\ncontourf(solution)\nsavefig(\"images/normsolver2.svg\") # hide","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"(Image: )","category":"page"},{"location":"devguide/#Simulation-solver-example-1","page":"Developer guide","title":"Simulation solver example","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"A simulation solver that, for each location of the domain, assigns a random sample from a Gaussian distribution.","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStatsBase\n\n# implement method for new solver\nimport GeoStatsBase: solvesingle\n\n@simsolver RandSolver begin\n  @param mean = 0\n  @param var  = 1\nend\n\nfunction solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::RandSolver, preproc)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # retrieve solver parameters\n    varparams = covars.params[(var,)]\n    μ, σ² = varparams.mean, varparams.var\n\n    # i.i.d. samples ~ Normal(0,1)\n    z = rand(npoints(pdomain))\n\n    # rescale and return\n    var => μ .+ sqrt(σ²) .* z\n  end\n\n  Dict(real4var)\nend;","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"We can test the newly defined solver in a simulation problem:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStats\nusing Plots\ngr(size=(900,300)) # hide\n\n# simulate on a regular grid\nsdomain = RegularGrid{Float64}(100, 100)\n\n# the problem to be solved\nproblem = SimulationProblem(sdomain, :z => Float64, 3)\n\n# our new solver\nsolver = RandSolver(:z => (mean=10.,var=10.))\n\nsolution = solve(problem, solver)\n\nheatmap(solution)\nsavefig(\"images/randsolver1.svg\") # hide","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"(Image: )","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"Note, however, that we did not define the preprocess function for the solver. This function can be used to avoid recalculations for each realization, and to set default parameters for variables that are not explicitly set by users in the solver constructor:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"import GeoStatsBase: preprocess\n\nfunction preprocess(problem::SimulationProblem, solver::RandSolver)\n  preproc = Dict()\n  for covars in covariables(problem, solver)\n    for varname in covars.names\n      varparams = covars.params[(varname,)]\n      preproc[varname] = (mean=varparams.mean, var=varparams.var)\n    end\n  end\n\n  preproc\nend;","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"We can call the preprocess function on problems with multiple variables to check that the solver is producing default values for variables other than the one passed during construction:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"problem = SimulationProblem(sdomain, (:z=>Float64, :w=>Float64), 3)\n\npreprocess(problem, solver)","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"This preproc output is passed by GeoStats.jl as the last argument to the solvesingle function, which could be reimplemented as follows:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"function solvesingle(problem::SimulationProblem, covars::NamedTuple,\n                     solver::RandSolver, preproc)\n  pdomain = domain(problem)\n\n  real4var = map(covars.names) do var\n    # retrieve solver parameters\n    μ, σ² = preproc[var]\n\n    # i.i.d. samples ~ Normal(0,1)\n    z = rand(npoints(pdomain))\n\n    # rescale and return\n    var => μ .+ sqrt(σ²) .* z\n  end\n\n  Dict(real4var)\nend;","category":"page"},{"location":"devguide/#Learning-solver-example-1","page":"Developer guide","title":"Learning solver example","text":"","category":"section"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"A learning solver that clusters data into super pixels:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStatsBase\n\n# implement method for new solver\nimport GeoStatsBase: solvesingle\n\nstruct SLICSolver <: AbstractLearningSolver\n  k::Int # approximate number of super pixels\n  m::Float64 # SLIC tradeoff parameter\nend\n\nfunction solve(problem::LearningProblem, solver::SLICSolver)\n  @assert task(problem) isa ClusteringTask \"invalid problem\"\n\n  # retrieve problem info\n  ptask  = task(problem)\n  feats  = collect(features(ptask))\n  tdata  = targetdata(problem)\n  output = outputvars(ptask)[1]\n\n  # find super pixels\n  slic = SLICPartitioner(solver.k, solver.m, vars=feats)\n  part = partition(tdata, slic)\n\n  # label for each point in target data\n  labels = Vector{Int}(undef, npoints(tdata))\n  for (i, inds) in enumerate(subsets(part))\n    labels[inds] .= i\n  end\n\n  # return learning solution\n  LearningSolution(domain(tdata), OrderedDict(output => labels))\nend;","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"We can test the newly defined solver in a learning problem:","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"using GeoStats\nusing Plots\ngr(size=(900,300)) # hide\n\nZ = [10sin(i/10) + j for i in 1:100, j in 1:100]\n\nΩ = RegularGridData{Float64}(OrderedDict(:Z=>Z))\n\nt = ClusteringTask(:Z, :SUPERPIXEL)\n\np = LearningProblem(Ω, Ω, t)\n\ns = solve(p, SLICSolver(50, 0.01))\n\nplot(plot(Ω), plot(s, c=:viridis))\nsavefig(\"images/slicsolver.svg\") # hide","category":"page"},{"location":"devguide/#","page":"Developer guide","title":"Developer guide","text":"(Image: )","category":"page"},{"location":"tutorials/#Tutorials-1","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"A set of Jupyter notebooks demonstrating the current functionality of the project is available in GeoStatsTutorials. Contributions are very welcome, please check the Contributing page.","category":"page"},{"location":"contributing/#Contributing-1","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"First off, thank you for considering contributing to GeoStats.jl. It’s people like you that make this project so much fun. Below are a few suggestions to speed up the collaboration process.","category":"page"},{"location":"contributing/#Reporting-issues-1","page":"Contributing","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and GeoStats.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"julia> versioninfo()\npkg> status","category":"page"},{"location":"contributing/#Feature-requests-1","page":"Contributing","title":"Feature requests","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in GeoStats.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/#Code-contribution-1","page":"Contributing","title":"Code contribution","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"If you have code that you would like to contribute to GeoStats.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"You can also develop your own solver independently, under your own license terms. Please check the Developer guide for information on how to write solvers that are compatible with the framework.","category":"page"},{"location":"links/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"links/#","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"links/#Types-1","page":"Index","title":"Types","text":"","category":"section"},{"location":"links/#","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links/#Functions-1","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links/#","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"data/#Spatial-data-1","page":"Data","title":"Spatial data","text":"","category":"section"},{"location":"data/#","page":"Data","title":"Data","text":"Below is the list of currently implemented spatial data types in the project.","category":"page"},{"location":"data/#GeoDataFrame-1","page":"Data","title":"GeoDataFrame","text":"","category":"section"},{"location":"data/#","page":"Data","title":"Data","text":"For point (or hard) data in spreadsheet format (e.g. CSV, TSV), the GeoDataFrame object is a lightweight wrapper over Julia's DataFrame types.","category":"page"},{"location":"data/#","page":"Data","title":"Data","text":"GeoDataFrame","category":"page"},{"location":"data/#GeoStatsBase.GeoDataFrame","page":"Data","title":"GeoStatsBase.GeoDataFrame","text":"GeoDataFrame(data, coordnames)\n\nA dataframe object data with additional metadata for tracking the columns coordnames that represent spatial coordinates.\n\nExamples\n\nIf the data was already loaded in a normal DataFrame data, and there exists columns named x, y and z, wrap the data and specify the column names:\n\njulia> GeoDataFrame(data, [:x,:y,:z])\n\nAlternatively, load the data directly into a GeoDataFrame object by using the method readgeotable.\n\nNotes\n\nThis type is a lightweight wrapper over Julia's DataFrame types. No additional storage is required other than a vector of symbols with the columns names representing spatial coordinates.\n\n\n\n\n\n","category":"type"},{"location":"data/#","page":"Data","title":"Data","text":"readgeotable","category":"page"},{"location":"data/#GeoStatsBase.readgeotable","page":"Data","title":"GeoStatsBase.readgeotable","text":"readgeotable(args; coordnames=[:x,:y,:z], kwargs)\n\nRead data from disk using CSV.read, optionally specifying the columns coordnames with spatial coordinates.\n\nThe arguments args and keyword arguments kwargs are forwarded to the CSV.read function, please check their documentation for more details.\n\nThis function returns a GeoDataFrame object.\n\n\n\n\n\n","category":"function"},{"location":"data/#PointSetData-1","page":"Data","title":"PointSetData","text":"","category":"section"},{"location":"data/#","page":"Data","title":"Data","text":"The PointSetData object is equivalent to GeoDataFrame except that it stores the data in a simple Julia OrderedDict instead of in a DataFrame.","category":"page"},{"location":"data/#","page":"Data","title":"Data","text":"PointSetData","category":"page"},{"location":"data/#GeoStatsBase.PointSetData","page":"Data","title":"GeoStatsBase.PointSetData","text":"PointSetData(data, coords)\n\nSpatial data georeferenced with coords, which can be a matrix or a vector of tuples. The data argument is a dictionary mapping variable names to Julia arrays with the actual data.\n\nSee also: PointSet\n\n\n\n\n\n","category":"type"},{"location":"data/#RegularGridData-1","page":"Data","title":"RegularGridData","text":"","category":"section"},{"location":"data/#","page":"Data","title":"Data","text":"In the case that the data is regularly spaced in a grid, the RegularGridData object provides fast access across multiple overlaid images.","category":"page"},{"location":"data/#","page":"Data","title":"Data","text":"RegularGridData","category":"page"},{"location":"data/#GeoStatsBase.RegularGridData","page":"Data","title":"GeoStatsBase.RegularGridData","text":"RegularGridData(data)\nRegularGridData(data, origin, spacing)\n\nRegularly spaced data georeferenced with origin and spacing. The data argument is a dictionary mapping variable names to Julia arrays with the actual data.\n\nNaN or missing values in the Julia arrays are interpreted as non-valid. They can be used to mask the variables on the grid.\n\nExamples\n\nGiven poro and perm two 2-dimensional Julia arrays containing values of porosity and permeability, the following code can be used to georeference the data:\n\njulia> data = OrderedDict(:porosity => poro, :permeability => perm)\njulia> RegularGridData(data, (0.,0.,0.), (1.,1.,1.))\n\nAlternatively, one can omit origin and spacing for default values of zeros and ones:\n\njulia> RegularGridData{Float64}(data)\n\nSee also: RegularGrid\n\n\n\n\n\n","category":"type"},{"location":"data/#StructuredGridData-1","page":"Data","title":"StructuredGridData","text":"","category":"section"},{"location":"data/#","page":"Data","title":"Data","text":"A StructuredGridData is a direct generalization of RegularGridData in which points can be localized in space with indices i,j,k... even though they are not regularly spaced. This format is often found in satellite data, NetCDF, etc.","category":"page"},{"location":"data/#","page":"Data","title":"Data","text":"StructuredGridData","category":"page"},{"location":"data/#GeoStatsBase.StructuredGridData","page":"Data","title":"GeoStatsBase.StructuredGridData","text":"StructuredGridData(data, X, Y, Z, ...)\n\nData spatially distributed on a structured grid where points are georeferenced by coordinates X, Y, Z, ...\n\nThe data argument is a dictionary mapping variable names to Julia arrays with the actual data.\n\nExamples\n\nA very popular structured grid data format is NetCDF. Given 2D arrays LAT and LON with coordinates and arrays with climate data precipitation, temperature, the following code can be used to construct a structured grid:\n\njulia> data = OrderedDict(:precipitation => precipitation, :temperature => temperature)\njulia> StructuredGridData(data, LAT, LON)\n\nSee also: StructuredGrid\n\n\n\n\n\n","category":"type"},{"location":"estimators/#Kriging-estimators-1","page":"Kriging estimators","title":"Kriging estimators","text":"","category":"section"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"A Kriging estimator has the form:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"newcommandxboldsymbolx\nnewcommandRmathbbR\nhatZ(x_0) = lambda_1 Z(x_1) + lambda_2 Z(x_2) + cdots + lambda_n Z(x_n)quad x_i in R^m lambda_i in R","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"with Zcolon R^m times Omega to R a random field.","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"This package implements the following Kriging variants:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"Simple Kriging\nOrdinary Kriging\nUniversal Kriging\nExternal Drift Kriging","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"All these variants follow the same interface: an estimator object is first created with a given set of parameters (e.g. estimator = OrdinaryKriging(γ)), it is then combined with the data krig = fit(estimator, X, z) to obtain predictions at new locations predict(krig, xₒ).","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"The fit function takes care of building the Kriging system and factorizing the LHS with an appropriate decomposition (e.g. Cholesky, LU):","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"KrigingEstimators.fit","category":"page"},{"location":"estimators/#StatsBase.fit","page":"Kriging estimators","title":"StatsBase.fit","text":"fit(estimator, X, z)\n\nFit estimator to coordinates X and values z, and return a fitted estimator.\n\n\n\n\n\n","category":"function"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"The predict function performs the estimation at a given location:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"predict","category":"page"},{"location":"estimators/#GeoStatsBase.predict","page":"Kriging estimators","title":"GeoStatsBase.predict","text":"predict(estimator, xₒ)\n\nPredict with the estimator at coordinates xₒ.\n\n\n\n\n\n","category":"function"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"Alternative constructors are provided for convenience that will immediately fit the Kriging parameters to the data. In this case, the data is passed as the first argument. For example:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"OrdinaryKriging(X, z, γ)","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"creates a OrdinaryKriging(γ) estimator and fits it to (X,z).","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"A typical use of the interface is as follows:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"# build and factorize the system\nsk = SimpleKriging(X, z, γ, mean(z))\n\n# estimate at various locations\nfor xₒ in [x₁, x₂, x₃]\n  μ, σ² = predict(sk, xₒ)\nend","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"For advanced users, the Kriging weights and Lagrange multipliers at a given location can be accessed with the weights method. This method returns a KrigingWeights object containing a field λ for the weights and a field ν for the Lagrange multipliers:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"weights","category":"page"},{"location":"estimators/#KrigingEstimators.weights","page":"Kriging estimators","title":"KrigingEstimators.weights","text":"weights(estimator, xₒ)\n\nCompute the weights λ (and Lagrange multipliers ν) for the estimator at coordinates xₒ.\n\n\n\n\n\n","category":"function"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"For example with Ordinary Kriging:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"ok = OrdinaryKriging(X, z, γ)\nw = weights(ok, xₒ)\nw.λ, w.ν","category":"page"},{"location":"estimators/#Simple-Kriging-1","page":"Kriging estimators","title":"Simple Kriging","text":"","category":"section"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"In Simple Kriging, the mean mu of the random field is assumed to be constant and known. The resulting linear system is:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"newcommandCboldsymbolC\nnewcommandcboldsymbolc\nnewcommandlboldsymbollambda\nnewcommand1boldsymbol1\nnewcommandzboldsymbolz\nbeginbmatrix\ncov(x_1x_1)  cov(x_1x_2)  cdots  cov(x_1x_n) \ncov(x_2x_1)  cov(x_2x_2)  cdots  cov(x_2x_n) \nvdots  vdots  ddots  vdots \ncov(x_nx_1)  cov(x_nx_2)  cdots  cov(x_nx_n)\nendbmatrix\nbeginbmatrix\nlambda_1 \nlambda_2 \nvdots \nlambda_n\nendbmatrix\n=\nbeginbmatrix\ncov(x_1x_0) \ncov(x_2x_0) \nvdots \ncov(x_nx_0)\nendbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"or in matricial form Cl = c. We subtract the given mean from the observations boldsymboly = z - mu 1 and compute the mean and variance at location x_0:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"mu(x_0) = mu + boldsymboly^top l","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"sigma^2(x_0) = cov(0) - c^top l","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"SimpleKriging","category":"page"},{"location":"estimators/#KrigingEstimators.SimpleKriging","page":"Kriging estimators","title":"KrigingEstimators.SimpleKriging","text":"SimpleKriging(γ, μ)\nSimpleKriging(X, z, γ, μ)\n\nSimple Kriging with variogram model γ and constant mean μ.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\nNotes\n\nSimple Kriging requires stationary variograms\n\n\n\n\n\n","category":"type"},{"location":"estimators/#Ordinary-Kriging-1","page":"Kriging estimators","title":"Ordinary Kriging","text":"","category":"section"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"In Ordinary Kriging the mean of the random field is assumed to be constant and unknown. The resulting linear system is:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"newcommandGboldsymbolGamma\nnewcommandgboldsymbolgamma\nbeginbmatrix\nG  1 \n1^top  0\nendbmatrix\nbeginbmatrix\nl \nnu\nendbmatrix\n=\nbeginbmatrix\ng \n1\nendbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"with nu the Lagrange multiplier associated with the constraint 1^top l = 1. The mean and variance at location x_0 are given by:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"mu(x_0) = z^top lambda","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"sigma^2(x_0) =  beginbmatrix g  1 endbmatrix^top beginbmatrix l  nu endbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"OrdinaryKriging","category":"page"},{"location":"estimators/#KrigingEstimators.OrdinaryKriging","page":"Kriging estimators","title":"KrigingEstimators.OrdinaryKriging","text":"OrdinaryKriging(γ)\nOrdinaryKriging(X, z, γ)\n\nOrdinary Kriging with variogram model γ.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\n\n\n\n\n","category":"type"},{"location":"estimators/#Universal-Kriging-1","page":"Kriging estimators","title":"Universal Kriging","text":"","category":"section"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"In Universal Kriging, the mean of the random field is assumed to be a polynomial of the spatial coordinates:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"mu(x) = sum_k=1^N_d beta_k f_k(x)","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"with N_d monomials f_k of degree up to d. For example, in 2D there are 6 monomials of degree up to 2:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"mu(x_1x_2) =  beta_1 1 + beta_2 x_1 + beta_3 x_2 + beta_4 x_1 x_2 + beta_5 x_1^2 + beta_6 x_2^2","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"The choice of the degree d determines the size of the polynomial matrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"newcommandFboldsymbolF\nnewcommandfboldsymbolf\nF =\nbeginbmatrix\nf_1(x_1)  f_2(x_1)  cdots  f_N_d(x_1) \nf_1(x_2)  f_2(x_2)  cdots  f_N_d(x_2) \nvdots  vdots  ddots  vdots \nf_1(x_n)  f_2(x_n)  cdots  f_N_d(x_n)\nendbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"and polynomial vector f = beginbmatrix f_1(x_0)  f_2(x_0)  cdots  f_N_d(x_0) endbmatrix^top.","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"The variogram determines the variogram matrix:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"G =\nbeginbmatrix\ngamma(x_1x_1)  gamma(x_1x_2)  cdots  gamma(x_1x_n) \ngamma(x_2x_1)  gamma(x_2x_2)  cdots  gamma(x_2x_n) \nvdots  vdots  ddots  vdots \ngamma(x_nx_1)  gamma(x_nx_2)  cdots  gamma(x_nx_n)\nendbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"and the variogram vector g = beginbmatrix gamma(x_1x_0)  gamma(x_2x_0)  cdots  gamma(x_nx_0) endbmatrix^top.","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"The resulting linear system is:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"beginbmatrix\nG  F \nF^top  boldsymbol0\nendbmatrix\nbeginbmatrix\nl \nboldsymbolnu\nendbmatrix\n=\nbeginbmatrix\ng \nf\nendbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"with boldsymbolnu the Lagrange multipliers associated with the universal constraints. The mean and variance at location x_0 are given by:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"mu(x_0) = z^top l","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"sigma^2(x_0) = beginbmatrixg  fendbmatrix^top beginbmatrixl  boldsymbolnuendbmatrix","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"UniversalKriging","category":"page"},{"location":"estimators/#KrigingEstimators.UniversalKriging","page":"Kriging estimators","title":"KrigingEstimators.UniversalKriging","text":"UniversalKriging(γ, degree, dim)\nUniversalKriging(X, z, γ, degree)\n\nUniversal Kriging with variogram model γ and polynomial degree on a spatial domain of dimension dim.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\nNotes\n\nOrdinaryKriging is recovered for 0th degree polynomial\nFor non-polynomial mean, see ExternalDriftKriging\n\n\n\n\n\n","category":"type"},{"location":"estimators/#External-Drift-Kriging-1","page":"Kriging estimators","title":"External Drift Kriging","text":"","category":"section"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"In External Drift Kriging, the mean of the random field is assumed to be a combination of known smooth functions:","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"mu(x) = sum_k beta_k m_k(x)","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"Differently than Universal Kriging, the functions m_k are not necessarily polynomials of the spatial coordinates. In practice, they represent a list of variables that is strongly correlated (and co-located) with the variable being estimated.","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"External drifts are known to cause numerical instability. Give preference to other Kriging variants if possible.","category":"page"},{"location":"estimators/#","page":"Kriging estimators","title":"Kriging estimators","text":"ExternalDriftKriging","category":"page"},{"location":"estimators/#KrigingEstimators.ExternalDriftKriging","page":"Kriging estimators","title":"KrigingEstimators.ExternalDriftKriging","text":"ExternalDriftKriging(γ, drifts)\nExternalDriftKriging(X, z, γ, drifts)\n\nExternal Drift Kriging with variogram model γ and external drifts functions.\n\nOptionally, pass the coordinates X and values z to the fit function.\n\nNotes\n\nExternal drift functions should be smooth\nKriging system with external drift is often unstable\nInclude a constant drift (e.g. x->1) for unbiased estimation\nOrdinaryKriging is recovered for drifts = [x->1]\nFor polynomial mean, see UniversalKriging\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Theoretical-variograms-1","page":"Theoretical variograms","title":"Theoretical variograms","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"newcommandxboldsymbolx\nnewcommandRmathbbR\nnewcommand1mathbb1","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"In an intrinsic isotropic model, the variogram is only a function of the distance between any two points x_1x_2 in R^m:","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(x_1x_2) = gamma(x_1 - x_2) = gamma(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"Under the additional assumption of 2nd-order stationarity, the well-known covariance is directly related via gamma(h) = cov(0) - cov(h). Anisotropic models are easily obtained by defining an ellipsoid distance in place of the Euclidean distance. For a list of available distances, please see Distances.jl.","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"This package implements a few commonly used and other more excentric variogram models. They all share the same default parameters:","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"sill=1\nrange=1\nnugget=0\ndistance=Euclidean()","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"Some of them have extra parameters that can be set with keyword arguments:","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"GaussianVariogram(nugget=.1) # set nugget effect\nMaternVariogram(order=1) # set order of Bessel function","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"Additionally, a composite (additive) variogram model gamma(h) = gamma_1(h) + gamma_2(h) + cdots gamma_n(h) can be constructed from a list of variogram models:","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"γ = GaussianVariogram() + ExponentialVariogram()","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"Like the other variogram models, a composite variogram gamma can be evaluated as an isotropic model gamma(h) or as a model with a custom distance gamma(x_1x_2).","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"Finally, the 2nd-order stationarity property of a variogram can be checked with the isstationary method:","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"isstationary","category":"page"},{"location":"theoretical_variograms/#Variography.isstationary","page":"Theoretical variograms","title":"Variography.isstationary","text":"isstationary(γ)\n\nCheck if variogram γ possesses the 2nd-order stationary property.\n\n\n\n\n\n","category":"function"},{"location":"theoretical_variograms/#Gaussian-1","page":"Theoretical variograms","title":"Gaussian","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - expleft(-3left(frachrright)^2right)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"GaussianVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.GaussianVariogram","page":"Theoretical variograms","title":"Variography.GaussianVariogram","text":"GaussianVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA Gaussian variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Exponential-1","page":"Theoretical variograms","title":"Exponential","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - expleft(-3left(frachrright)right)right + n cdot 1_(0infty)(h)\n","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"ExponentialVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.ExponentialVariogram","page":"Theoretical variograms","title":"Variography.ExponentialVariogram","text":"ExponentialVariogram(sill=s, range=r, nugget=n, distance=d)\n\nAn exponential variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Matern-1","page":"Theoretical variograms","title":"Matern","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - frac2^1-nuGamma(nu) left(sqrt2nufrachrright)^nu K_nuleft(sqrt2nufrachrright)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"MaternVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.MaternVariogram","page":"Theoretical variograms","title":"Variography.MaternVariogram","text":"MaternVariogram(sill=s, range=r, nugget=n, order=ν, distance=d)\n\nA Matérn variogram with sill s, range r and nugget n. The parameter ν is the order of the Bessel function. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Spherical-1","page":"Theoretical variograms","title":"Spherical","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(frac32left(frachrright) + frac12left(frachrright)^3right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"SphericalVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.SphericalVariogram","page":"Theoretical variograms","title":"Variography.SphericalVariogram","text":"SphericalVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA spherical variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Cubic-1","page":"Theoretical variograms","title":"Cubic","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(7left(frachrright)^2 - frac354left(frachrright)^3 + frac72left(frachrright)^5 - frac34left(frachrright)^7right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"CubicVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.CubicVariogram","page":"Theoretical variograms","title":"Variography.CubicVariogram","text":"CubicVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA cubic variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Pentaspherical-1","page":"Theoretical variograms","title":"Pentaspherical","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) leftleft(frac158left(frachrright) - frac54left(frachrright)^3 + frac38left(frachrright)^5right) cdot 1_(0r)(h) + 1_rinfty)(h)right + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"PentasphericalVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.PentasphericalVariogram","page":"Theoretical variograms","title":"Variography.PentasphericalVariogram","text":"PentasphericalVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA pentaspherical variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Power-1","page":"Theoretical variograms","title":"Power","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = sh^a + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"PowerVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.PowerVariogram","page":"Theoretical variograms","title":"Variography.PowerVariogram","text":"PowerVariogram(scaling=s, exponent=a, nugget=n, distance=d)\n\nA power variogram with scaling s, exponent a and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Sine-hole-1","page":"Theoretical variograms","title":"Sine hole","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"gamma(h) = (s - n) left1 - fracsin(pi h  r)pi h  rright + n cdot 1_(0infty)(h)","category":"page"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"SineHoleVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.SineHoleVariogram","page":"Theoretical variograms","title":"Variography.SineHoleVariogram","text":"SineHoleVariogram(sill=s, range=r, nugget=n, distance=d)\n\nA sine hole variogram with sill s, range r and nugget n. Optionally, use a custom distance d.\n\n\n\n\n\n","category":"type"},{"location":"theoretical_variograms/#Composite-1","page":"Theoretical variograms","title":"Composite","text":"","category":"section"},{"location":"theoretical_variograms/#","page":"Theoretical variograms","title":"Theoretical variograms","text":"CompositeVariogram","category":"page"},{"location":"theoretical_variograms/#Variography.CompositeVariogram","page":"Theoretical variograms","title":"Variography.CompositeVariogram","text":"CompositeVariogram(γ₁, γ₂, ..., γₙ)\n\nA composite (additive) model of variograms γ(h) = γ₁(h) + γ₂(h) + ⋯ + γₙ(h).\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Solver-comparisons-1","page":"Solver comparisons","title":"Solver comparisons","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"GeoStats.jl was designed to, among other things, facilitate rigorous scientific comparison of different geostatistical solvers in the literature. As a user of geostatistics, you may be interested in applying various solvers on a given data set and pick the ones with best performance. As a researcher in the field, you may be interested in benchmarking your new algorithm against other established methods.","category":"page"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"Typically, this task would demand a great amount of time from the practitioner, which would become responsible for pre/post processing the data himself/herself before it can be fed into the software. But that is not the only issue, quantitative comparison of geostatistical solvers is an area of active research. Although a few comparison methods exist, their implementation is not necessarily straighforward.","category":"page"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"In this project, solvers can be compared without effort. Below is a list of currenlty implemented comparison methods. For examples of usage, please consult the GeoStatsTutorials repository.","category":"page"},{"location":"comparisons/#Cross-validation-1","page":"Solver comparisons","title":"Cross-validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"CrossValidation","category":"page"},{"location":"comparisons/#GeoStatsBase.CrossValidation","page":"Solver comparisons","title":"GeoStatsBase.CrossValidation","text":"CrossValidation(k; shuffle=true, loss=Dict())\n\nk-fold cross-validation. Optionally, shuffle the data, and specify loss function  from `LossFunctions.jl for some of the variables.\n\nCrossValidation(partitioner; loss=Dict())\n\nGeneralization of k-fold cross-validation in which the data is split using partitioner.\n\nReferences\n\nHastie et al. 2001. The Elements of Statistical Learning.\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Block-cross-validation-1","page":"Solver comparisons","title":"Block cross-validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"BlockCrossValidation","category":"page"},{"location":"comparisons/#GeoStatsBase.BlockCrossValidation","page":"Solver comparisons","title":"GeoStatsBase.BlockCrossValidation","text":"BlockCrossValidation(side; loss=Dict())\n\nCross-validation with blocks of given side. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nReferences\n\nRoberts et al. 2017. Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure.\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Leave-ball-out-validation-1","page":"Solver comparisons","title":"Leave-ball-out validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"LeaveBallOut","category":"page"},{"location":"comparisons/#GeoStatsBase.LeaveBallOut","page":"Solver comparisons","title":"GeoStatsBase.LeaveBallOut","text":"LeaveBallOut(ball; loss=Dict())\n\nLeave-ball-out (a.k.a. spatial leave-one-out) validation. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nLeaveBallOut(radius; ndims=3, loss=Dict())\n\nBy default, use Euclidean ball of given radius in space with ndims dimensions.\n\nReferences\n\nLe Rest et al. 2014. Spatial leave-one-out cross-validation for variable selection in the presence of spatial autocorrelation.\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Weighted-cross-validation-1","page":"Solver comparisons","title":"Weighted cross-validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"WeightedCrossValidation","category":"page"},{"location":"comparisons/#GeoStatsBase.WeightedCrossValidation","page":"Solver comparisons","title":"GeoStatsBase.WeightedCrossValidation","text":"WeightedCrossValidation(weighter, partitioner;\n                        lambda=1.0, loss=Dict())\n\nWeighted cross-validation in which samples are split into folds with partitioner method and are weighted with weighter method. Weights are raised to lambda power in [0,1]. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\nWeightedCrossValidation(weighter, k; shuffle=true,\n                        lambda=1.0, loss=Dict())\n\nAlternatively, specify the desired number of folds k and shuffle options for a UniformPartitioner.\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Weighted-hold-out-validation-1","page":"Solver comparisons","title":"Weighted hold-out validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"WeightedHoldOut","category":"page"},{"location":"comparisons/#GeoStatsBase.WeightedHoldOut","page":"Solver comparisons","title":"GeoStatsBase.WeightedHoldOut","text":"WeightedHoldOut(weighter, fraction; loss=Dict())\n\nWeighted loss validation with train / hold-out split. The source data of the problem is split with a fraction into train and hold-out sets, and the samples are weighted with a weighter method. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Weighted-bootstrap-validation-1","page":"Solver comparisons","title":"Weighted bootstrap validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"WeightedBootstrap","category":"page"},{"location":"comparisons/#GeoStatsBase.WeightedBootstrap","page":"Solver comparisons","title":"GeoStatsBase.WeightedBootstrap","text":"WeightedBootstrap(weighter, nsamples; loss=Dict())\n\nWeighted bootstrap with nsamples samples drawn with replacement using the weights produced by weighter. Optionally, specify loss function from LossFunctions.jl for some of the variables.\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Density-ratio-validation-1","page":"Solver comparisons","title":"Density-ratio validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"DensityRatioValidation","category":"page"},{"location":"comparisons/#GeoStatsBase.DensityRatioValidation","page":"Solver comparisons","title":"GeoStatsBase.DensityRatioValidation","text":"DensityRatioValidation(k; [options])\n\nDesntity ratio validation where weights are first obtained with density ratio estimation, and then used in k-fold weighted cross-validation.\n\nOptions\n\nestimator - Density ratio estimator (default to LSIF())\noptlib    - Optimization library (default to default_optlib(estimator))\nlambda    - Power of density ratios (default to 1.0)\n\n\n\n\n\n","category":"type"},{"location":"comparisons/#Ball-sample-validation-1","page":"Solver comparisons","title":"Ball-sample validation","text":"","category":"section"},{"location":"comparisons/#","page":"Solver comparisons","title":"Solver comparisons","text":"BallSampleValidation","category":"page"},{"location":"comparisons/#GeoStatsBase.BallSampleValidation","page":"Solver comparisons","title":"GeoStatsBase.BallSampleValidation","text":"BallSampleValidation(eestimator, sourceradius, targetradius;\n                     metric=Euclidean(), tol=1e-4, maxiter=10)\n\nBall sample validation with error estimator eestimator, based on samples collected from source and target data. sourceradius is the radius of the ball for the source data and targetradius is the radius of the ball for the target data.\n\n\n\n\n\n","category":"type"},{"location":"about/license/#","page":"License","title":"License","text":"The GeoStats.jl package is licensed under the ISC License:","category":"page"},{"location":"about/license/#","page":"License","title":"License","text":"Copyright (c) 2015, Júlio Hoffimann Mendes <juliohm@stanford.edu>\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","category":"page"},{"location":"domains/#Domains-1","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"domains/#","page":"Domains","title":"Domains","text":"Although estimators such as Kriging do not require equally spaced samples, many software packages for geostatistical estimation/simulation restrict their implementations to regular grids. This is a big limitation, however; given that sampling campaigns and resource exploration is rarely regular.","category":"page"},{"location":"domains/#","page":"Domains","title":"Domains","text":"In GeoStats.jl, estimation/simulation can be performed on arbitrary domain types such as simple point sets, unstructured meshes, and tesselations. These types are implemented \"analytically\" in order to minimize memory access and maximize performance. In a regular grid, for example, the coordinates of a given location are known, and one can perform search without ever constructing a grid.","category":"page"},{"location":"domains/#","page":"Domains","title":"Domains","text":"Below is the list of currently implemented domain types. More options will be available in future releases.","category":"page"},{"location":"domains/#PointSet-1","page":"Domains","title":"PointSet","text":"","category":"section"},{"location":"domains/#","page":"Domains","title":"Domains","text":"PointSet","category":"page"},{"location":"domains/#GeoStatsBase.PointSet","page":"Domains","title":"GeoStatsBase.PointSet","text":"PointSet(coords)\n\nA set of points with coordinate matrix coords. The number of rows of the matrix is the dimensionality of the domain whereas the number of columns is the number of points in the set. Alternatively, coords can be a vector of tuples (i.e. points).\n\n\n\n\n\n","category":"type"},{"location":"domains/#RegularGrid-1","page":"Domains","title":"RegularGrid","text":"","category":"section"},{"location":"domains/#","page":"Domains","title":"Domains","text":"RegularGrid","category":"page"},{"location":"domains/#GeoStatsBase.RegularGrid","page":"Domains","title":"GeoStatsBase.RegularGrid","text":"RegularGrid(dims, origin, spacing)\n\nA regular grid with dimensions dims, lower left corner at origin and cell spacing spacing. The three arguments must have the same length.\n\nRegularGrid(start, finish, dims=dims)\n\nAlternatively, construct a regular grid from a start point (lower left) to a finish point (upper right).\n\nRegularGrid{T}(dims)\nRegularGrid{T}(dim1, dim2, ...)\n\nFinally, a regular grid can be constructed by only passing the dimensions dims as a tuple, or by passing each dimension dim1, dim2, ... separately. In this case, the origin and spacing default to (0,0,...) and (1,1,...).\n\nExamples\n\nCreate a 3D grid with 100x100x50 locations:\n\njulia> RegularGrid{Float64}(100,100,50)\n\nCreate a 2D grid with 100x100 locations and origin at (10.,20.) units:\n\njulia> RegularGrid((100,100),(10.,20.),(1.,1.))\n\nCreate a 1D grid from -1 to 1 with 100 locations:\n\njulia> RegularGrid((-1.,),(1.,), dims=(100,))\n\n\n\n\n\n","category":"type"},{"location":"domains/#StructuredGrid-1","page":"Domains","title":"StructuredGrid","text":"","category":"section"},{"location":"domains/#","page":"Domains","title":"Domains","text":"StructuredGrid","category":"page"},{"location":"domains/#GeoStatsBase.StructuredGrid","page":"Domains","title":"GeoStatsBase.StructuredGrid","text":"StructuredGrid(X, Y, Z, ...)\n\nA structured grid with coordinates X, Y, Z, ...\n\nExamples\n\nA 2D structured grid can be constructed from coordinates stored in 2D matrices. For example, we can georeference locations in the Earth surface using LAT and LON coordinates:\n\njulia> StructuredGrid(LAT, LON)\n\n\n\n\n\n","category":"type"},{"location":"related/#Related-packages-1","page":"Related packages","title":"Related packages","text":"","category":"section"},{"location":"related/#GaussianProcesses.jl-1","page":"Related packages","title":"GaussianProcesses.jl","text":"","category":"section"},{"location":"related/#","page":"Related packages","title":"Related packages","text":"GaussianProcesses.jl - Gaussian processes (the method) and Simple Kriging are essentially two names for the same concept. The derivation of Kriging estimators, however; does not require distributional assumptions. It is a beautiful coincidence that for multivariate Gaussian distributions, Simple Kriging gives the conditional expectation. Matheron and other important geostatisticians have generalized Gaussian processes to more general random fields with locally-varying mean and for situations where the mean is unknown. GeoStats.jl includes Gaussian processes as a special case as well as other more practical Kriging variants, see the Gaussian processes example.","category":"page"},{"location":"related/#MLKernels.jl-1","page":"Related packages","title":"MLKernels.jl","text":"","category":"section"},{"location":"related/#","page":"Related packages","title":"Related packages","text":"MLKernels.jl - Spatial structure can be represented in many different forms: covariance, variogram, correlogram, etc. Variograms are more general than covariance kernels according to the intrinsic stationary property. This means that there are variogram models with no covariance counterpart. Furthermore, empirical variograms can be easily estimated from the data (in various directions) with an efficient procedure. GeoStats.jl treats variograms as first-class objects, see the Variogram modeling example.","category":"page"},{"location":"related/#Interpolations.jl-1","page":"Related packages","title":"Interpolations.jl","text":"","category":"section"},{"location":"related/#","page":"Related packages","title":"Related packages","text":"Interpolations.jl - Kriging and Spline interpolation have different purposes, yet these two methods are sometimes listed as competing alternatives. Kriging estimation is about minimizing variance (or estimation error), whereas Spline interpolation is about forcedly smooth estimators derived for computer visualization. Kriging is a generalization of Splines in which one has the freedom to customize spatial structure based on data. Besides the estimate itself, Kriging also provides the variance map as a function of knots configuration.","category":"page"},{"location":"related/#MLJ.jl-1","page":"Related packages","title":"MLJ.jl","text":"","category":"section"},{"location":"related/#","page":"Related packages","title":"Related packages","text":"MLJ.jl - Statistical learning (a.k.a. machine learning) theory relies on a set of assumptions that do not hold with spatial data (e.g i.i.d. samples on fixed-size support, stationarity, to name a few). Geostatistical learning theory generalizes traditional machine learning for applications where statistical models need to be learned from spatial data.","category":"page"},{"location":"operations/#Spatial-operations-1","page":"Spatial operations","title":"Spatial operations","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"Below is a list of spatial operations implemented in the GeoStats.jl framework.","category":"page"},{"location":"operations/#Partitioning-1","page":"Spatial operations","title":"Partitioning","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"UniformPartitioner\nFractionPartitioner\nSLICPartitioner\nBlockPartitioner\nBisectPointPartitioner\nBisectFractionPartitioner\nBallPartitioner\nPlanePartitioner\nDirectionPartitioner\nVariablePartitioner\nPredicatePartitioner\nSpatialPredicatePartitioner\nProductPartitioner\nHierarchicalPartitioner","category":"page"},{"location":"operations/#GeoStatsBase.UniformPartitioner","page":"Spatial operations","title":"GeoStatsBase.UniformPartitioner","text":"UniformPartitioner(k, [shuffle])\n\nA method for partitioning spatial data uniformly into k subsets of approximately equal size. Optionally shuffle the data (default to true).\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.FractionPartitioner","page":"Spatial operations","title":"GeoStatsBase.FractionPartitioner","text":"FractionPartitioner(fraction, shuffle=true)\n\nA method for partitioning spatial objects according to a given fraction. Optionally shuffle elements before partitioning.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.SLICPartitioner","page":"Spatial operations","title":"GeoStatsBase.SLICPartitioner","text":"SLICPartitioner(k, m; tol=1e-4, maxiter=10, vars=nothing)\n\nA method for partitioning spatial data into approximately k clusters using Simple Linear Iterative Clustering (SLIC). The method produces clusters of samples that are spatially connected based on a distance dₛ and that, at the same time, are similar in terms of vars with distance dᵥ. The tradeoff is controlled with a hyperparameter parameter m in an additive model dₜ = √(dᵥ² + m²(dₛ/s)²).\n\nParameters\n\nk       - Approximate number of clusters\nm       - Hyperparameter of SLIC model\ntol     - Tolerance of k-means algorithm (default to 1e-4)\nmaxiter - Maximum number of iterations (default to 10)\nvars    - Variables (or features) to consider (default to all)\n\nReferences\n\nAchanta et al. 2011. SLIC superpixels compared to state-of-the-art superpixel methods.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.BlockPartitioner","page":"Spatial operations","title":"GeoStatsBase.BlockPartitioner","text":"BlockPartitioner(side)\n\nA method for partitioning spatial objects into blocks of given side.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.BisectPointPartitioner","page":"Spatial operations","title":"GeoStatsBase.BisectPointPartitioner","text":"BisectPointPartitioner(normal, point)\n\nA method for partitioning spatial data into two half spaces defined by a normal direction and a reference point.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.BisectFractionPartitioner","page":"Spatial operations","title":"GeoStatsBase.BisectFractionPartitioner","text":"BisectFractionPartitioner(normal, fraction=0.5, maxiter=10)\n\nA method for partitioning spatial data into two half spaces defined by a normal direction and a fraction of points. The partition is returned within maxiter bisection iterations.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.BallPartitioner","page":"Spatial operations","title":"GeoStatsBase.BallPartitioner","text":"BallPartitioner(radius; metric=Euclidean())\n\nA method for partitioning spatial objects into balls of a given radius using a metric.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.PlanePartitioner","page":"Spatial operations","title":"GeoStatsBase.PlanePartitioner","text":"PlanePartitioner(normal; tol=1e-6)\n\nA method for partitioning spatial data into a family of hyperplanes defined by a normal direction. Two points x and y belong to the same hyperplane when (x - y) ⋅ normal < tol.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.DirectionPartitioner","page":"Spatial operations","title":"GeoStatsBase.DirectionPartitioner","text":"DirectionPartitioner(direction; tol=1e-6)\n\nA method for partitioning spatial objects along a given direction with bandwidth tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.VariablePartitioner","page":"Spatial operations","title":"GeoStatsBase.VariablePartitioner","text":"VariablePartitioner(var)\n\nA method for partitioning spatial data into subsets of constant value for variable var.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.PredicatePartitioner","page":"Spatial operations","title":"GeoStatsBase.PredicatePartitioner","text":"PredicatePartitioner(pred)\n\nA method for partitioning spatial objects with a given predicate function pred(i, j).\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.SpatialPredicatePartitioner","page":"Spatial operations","title":"GeoStatsBase.SpatialPredicatePartitioner","text":"SpatialPredicatePartitioner(pred)\n\nA method for partitioning spatial objects with a given spatial predicate function pred(x, y).\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.ProductPartitioner","page":"Spatial operations","title":"GeoStatsBase.ProductPartitioner","text":"ProductPartitioner(p₁, p₂)\n\nA method for partitioning spatial objects using the product of two partitioners p₁ and p₂.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.HierarchicalPartitioner","page":"Spatial operations","title":"GeoStatsBase.HierarchicalPartitioner","text":"HierarchicalPartitioner(first, second)\n\nA partitioning method in which a first partition is applied and then a second partition is applied to each subset of the first.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Weighting-1","page":"Spatial operations","title":"Weighting","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"BlockWeighter\nDensityRatioWeighter","category":"page"},{"location":"operations/#GeoStatsBase.BlockWeighter","page":"Spatial operations","title":"GeoStatsBase.BlockWeighter","text":"BlockWeighter(side)\n\nA weighting method that assigns weights to points in spatial object based on blocks of given side. The number (n) of points inside a block determines the weights (1/n) of these points.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.DensityRatioWeighter","page":"Spatial operations","title":"GeoStatsBase.DensityRatioWeighter","text":"DensityRatioWeighter(tdata; [options])\n\nDensity ratio weights based on empirical distribution of variables in target data tdata.\n\nOptional parameters\n\nvariables - Variables to consider (default to all)\nestimator - Density ratio estimator (default to LSIF())\noptlib    - Optimization library (default to default_optlib(estimator))\n\nNotes\n\nEstimators from DensityRatioEstimation.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Sampling-1","page":"Spatial operations","title":"Sampling","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"UniformSampler\nBallSampler\nWeightedSampler","category":"page"},{"location":"operations/#GeoStatsBase.UniformSampler","page":"Spatial operations","title":"GeoStatsBase.UniformSampler","text":"UniformSampler(size, replace=false)\n\nA method for uniform sampling from spatial objects that produces samples of given size with or without replacement depending on the option replace.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.BallSampler","page":"Spatial operations","title":"GeoStatsBase.BallSampler","text":"BallSampler(radius; [options])\n\nA method for sampling isolated points from spatial objects using a ball neighborhood of given radius.\n\nOptions\n\nmetric  - Metric for the ball (default to Euclidean())\nmaxsize - Maximum size of the resulting sample (default to none)\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.WeightedSampler","page":"Spatial operations","title":"GeoStatsBase.WeightedSampler","text":"WeightedSampler(size, [weights]; replace=false)\n\nA method for weighted sampling from spatial objects that produces samples of given size based on weights with or without replacement depending on the option replace. By default weights are uniform.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Filtering-1","page":"Spatial operations","title":"Filtering","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"UniqueCoordsFilter","category":"page"},{"location":"operations/#GeoStatsBase.UniqueCoordsFilter","page":"Spatial operations","title":"GeoStatsBase.UniqueCoordsFilter","text":"UniqueCoordsFilter([options])\n\nA filter method to retain locations in spatial objects with unique coordinates.\n\nOptions\n\naggreg - Dictionary with aggregation function for each variable\nmetric - Metric (default to Euclidean())\ntol    - Tolerance for coordinates distance (default to 1e-6)\n\nDuplicates of a variable var are aggregated with aggregation function aggreg[var]. Default aggregation function is mean for continuous variables and first otherwise.\n\nCoordinates are unique according to metric and tol.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Joining-1","page":"Spatial operations","title":"Joining","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"VariableJoiner","category":"page"},{"location":"operations/#GeoStatsBase.VariableJoiner","page":"Spatial operations","title":"GeoStatsBase.VariableJoiner","text":"VariableJoiner()\n\nJoin spatial data with shared domain to produce spatial data with all variables included.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Searching-1","page":"Spatial operations","title":"Searching","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"NeighborhoodSearcher\nNearestNeighborSearcher\nBoundedSearcher","category":"page"},{"location":"operations/#GeoStatsBase.NeighborhoodSearcher","page":"Spatial operations","title":"GeoStatsBase.NeighborhoodSearcher","text":"NeighborhoodSearcher(object, neighborhood)\n\nA method for searching neighbors in spatial object inside neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.NearestNeighborSearcher","page":"Spatial operations","title":"GeoStatsBase.NearestNeighborSearcher","text":"NearestNeighborSearcher(object, k; locations=all, metric=Euclidean())\n\nA method for searching k nearest neighbors in spatial object locations according to metric.\n\n\n\n\n\n","category":"type"},{"location":"operations/#GeoStatsBase.BoundedSearcher","page":"Spatial operations","title":"GeoStatsBase.BoundedSearcher","text":"BoundedSearcher(searcher, nmax)\n\nA method for searching at most nmax neighbors using searcher.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Covering-1","page":"Spatial operations","title":"Covering","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"RectangleCoverer","category":"page"},{"location":"operations/#GeoStatsBase.RectangleCoverer","page":"Spatial operations","title":"GeoStatsBase.RectangleCoverer","text":"RectangleCoverer\n\nA method for covering spatial objects with a minimum axis-aligned bounding rectangle (or bounding box).\n\n\n\n\n\n","category":"type"},{"location":"operations/#Discretizing-1","page":"Spatial operations","title":"Discretizing","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"RegularGridDiscretizer","category":"page"},{"location":"operations/#GeoStatsBase.RegularGridDiscretizer","page":"Spatial operations","title":"GeoStatsBase.RegularGridDiscretizer","text":"RegularGridDiscretizer(dims)\n\nDiscretize spatial region into regular grid of given dimensions dims.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Statistics-1","page":"Spatial operations","title":"Statistics","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"The term spatial statistics can refer to statistics computed with samples collected in a spatial domain (a.k.a. spatial data), or to statistics computed with multiple realizations of a random field (e.g. multiple maps).","category":"page"},{"location":"operations/#Statistics-from-spatial-data-1","page":"Spatial operations","title":"Statistics from spatial data","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"The following statistics have spatial semantics (i.e. make use of spatial coordinates), and as such, approximate better spatial variables when compared to their non-spatial counterparts:","category":"page"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"EmpiricalHistogram","category":"page"},{"location":"operations/#GeoStatsBase.EmpiricalHistogram","page":"Spatial operations","title":"GeoStatsBase.EmpiricalHistogram","text":"EmpiricalHistogram(spatialdata)\n\nSpatial histogram of spatialdata.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Statistics-from-random-field-1","page":"Spatial operations","title":"Statistics from random field","text":"","category":"section"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"A set of geostatistical realizations of a random field represents a probability distribution. It is often useful to compute summary statistics with this set (e.g. location-wise mean and variance) and try understand spatial trends. In GeoStats.jl a set of realizations is stored in a SimulationSolution object. Currently, the following statistics are defined:","category":"page"},{"location":"operations/#","page":"Spatial operations","title":"Spatial operations","text":"mean(::SimulationSolution)\nvar(::SimulationSolution)\nquantile(::SimulationSolution, ::Real)","category":"page"},{"location":"operations/#Statistics.mean-Tuple{SimulationSolution}","page":"Spatial operations","title":"Statistics.mean","text":"mean(solution)\n\nMean of simulation solution.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Statistics.var-Tuple{SimulationSolution}","page":"Spatial operations","title":"Statistics.var","text":"var(solution)\n\nVariance of simulation solution.\n\n\n\n\n\n","category":"method"},{"location":"operations/#Statistics.quantile-Tuple{SimulationSolution,Real}","page":"Spatial operations","title":"Statistics.quantile","text":"quantile(solution, p)\n\np-quantile of simulation solution.\n\n\n\n\n\n","category":"method"},{"location":"problems/#Problems-1","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"One of the greatest features of GeoStats.jl is the ability to define geostatistical problems independently of the solution strategy. This design allows researchers and practioners to perform fair comparisons between different solvers.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"If you are an experienced user of geostatistics or if you do research in the field, you know how hard it is to compare algorithms fairly. Often a new algorithm is proposed in the literature, and yet the task of comparing it with the state of the art is quite demanding. Even when a comparison is made by the author after a great amount of effort, it is inevitably biased.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Part of this issue is attributed to the fact that a formal definition of geostatistical problems is missing. The project provides solutions to three problems defined below.","category":"page"},{"location":"problems/#Estimation-problem-1","page":"Problems","title":"Estimation problem","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"An estimation problem in geostatitsics is a triplet:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Spatial data (i.e. data with coordinates)\nSpatial domain (e.g. regular grid, point collection)\nTarget variables (or variables to be estimated)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Each of these components is constructed separately, and then grouped (no memory is copied) in an EstimationProblem.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"EstimationProblem","category":"page"},{"location":"problems/#GeoStatsBase.EstimationProblem","page":"Problems","title":"GeoStatsBase.EstimationProblem","text":"EstimationProblem(sdata, sdomain, targetvars)\n\nA spatial estimation problem on a given spatial domain sdomain in which the variables to be estimated are listed in targetvars. The data of the problem is stored in spatial data sdata.\n\nExamples\n\nCreate an estimation problem for rainfall precipitation measurements:\n\njulia> EstimationProblem(sdata, sdomain, :precipitation)\n\nCreate an estimation problem for precipitation and CO₂:\n\njulia> EstimationProblem(sdata, sdomain, (:precipitation,:CO₂))\n\n\n\n\n\n","category":"type"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Please check Spatial data and Domains for currently implemented data and domain types.","category":"page"},{"location":"problems/#Simulation-problem-1","page":"Problems","title":"Simulation problem","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Likewise, a stochastic simulation problem in geostatistics is represented with the same triplet. However, the spatial data in this case is optional in order to accomodate the concept of conditional versus unconditional simulation.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"SimulationProblem","category":"page"},{"location":"problems/#GeoStatsBase.SimulationProblem","page":"Problems","title":"GeoStatsBase.SimulationProblem","text":"SimulationProblem(sdata, sdomain, targetvars, nreals)\nSimulationProblem(sdomain, targetvars, nreals)\n\nA spatial simulation problem on a given spatial domain sdomain in which the variables to be simulated are listed in targetvars.\n\nFor conditional simulation, the data of the problem is stored in spatial data sdata.\n\nFor unconditional simulation, a list of pairs targetvars must be provided mapping variable names to their types.\n\nIn both cases, a number nreals of realizations is requested.\n\nExamples\n\nCreate a conditional simulation problem for porosity and permeability with 100 realizations:\n\njulia> SimulationProblem(sdata, sdomain, (:porosity,:permeability), 100)\n\nCreate an unconditional simulation problem for porosity and facies type with 100 realizations:\n\njulia> SimulationProblem(sdomain, (:porosity => Float64, :facies => Int), 100)\n\nNotes\n\nTo check if a simulation problem has data (i.e. conditional vs. unconditional) use the hasdata method.\n\n\n\n\n\n","category":"type"},{"location":"problems/#","page":"Problems","title":"Problems","text":"hasdata","category":"page"},{"location":"problems/#GeoStatsBase.hasdata","page":"Problems","title":"GeoStatsBase.hasdata","text":"hasdata(problem)\n\nReturn true if simulation problem has data.\n\n\n\n\n\n","category":"function"},{"location":"problems/#Learning-problem-1","page":"Problems","title":"Learning problem","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"A geostatistical learning problem consists of a triplet:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Source spatial data (e.g. with labels)\nTarget spatial data (e.g. without labels)\nLearning task (e.g. classification)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"In this case, a learning model is trained with the source spatial data, and then used to perform the same task with the target spatial data.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"LearningProblem","category":"page"},{"location":"problems/#GeoStatsBase.LearningProblem","page":"Problems","title":"GeoStatsBase.LearningProblem","text":"LearningProblem(sdata, tdata, task)\n\nA spatial learning problem with source data sdata, target data tdata, and learning task.\n\nExamples\n\nCreate a clustering problem based on a set of soil features:\n\njulia> LearningProblem(sdata, tdata,\n                       ClusteringTask((:moisture,:mineral)))\n\n\n\n\n\n","category":"type"},{"location":"problems/#Built-in-solvers-1","page":"Problems","title":"Built-in solvers","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Below is the list of solvers distributed with GeoStats.jl. For more solvers, please check the project page on GitHub where a table is provided with links to accompanying repositories.","category":"page"},{"location":"problems/#Estimation-solvers-1","page":"Problems","title":"Estimation solvers","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Kriging","category":"page"},{"location":"problems/#KrigingEstimators.Kriging","page":"Problems","title":"KrigingEstimators.Kriging","text":"Kriging(var₁=>param₁, var₂=>param₂, ...)\n\nA polyalgorithm Kriging estimation solver.\n\nEach pair var=>param specifies the KrigingParam param for the Kriging variable var. In order to avoid boilerplate code, the constructor expects pairs of Symbol and NamedTuple instead.\n\nParameters\n\nvariogram - Variogram model (default to GaussianVariogram())\nmean      - Simple Kriging mean\ndegree    - Universal Kriging degree\ndrifts    - External Drift Kriging drift functions\n\nLatter options override former options. For example, by specifying drifts, the user is telling the algorithm to ignore degree and mean. If no option is specified, Ordinary Kriging is used by default with the variogram only.\n\nmaxneighbors - Maximum number of neighbors (default to nothing)\nneighborhood - Search neighborhood (default to nothing)\ndistance     - Distance used to find nearest neighbors (default to Euclidean())\n\nThe maxneighbors option can be used to perform approximate Kriging with a subset of data points per estimation location. Two neighborhood search methods are available depending on the value of neighborhood:\n\nIf a neighborhood is provided, local Kriging is performed by sliding the neighborhood in the domain.\nIf neighborhood is not provided, the Kriging system is built using maxneighbors nearest neighbors according to a distance.\n\nExamples\n\nSolve the variable :var₁ with Simple Kriging by specifying the mean, and the variable :var₂ with Universal Kriging by specifying the degree and the variogram model.\n\njulia> Kriging(\n  :var₁ => (mean=1.,),\n  :var₂ => (degree=1, variogram=SphericalVariogram(range=20.))\n)\n\nSolve all variables of the problem with the default parameters (i.e. Ordinary Kriging with unit Gaussian variogram):\n\njulia> Kriging()\n\n\n\n\n\n\n\n","category":"type"},{"location":"problems/#Simulation-solvers-1","page":"Problems","title":"Simulation solvers","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"SeqGaussSim","category":"page"},{"location":"problems/#KrigingEstimators.SeqGaussSim","page":"Problems","title":"KrigingEstimators.SeqGaussSim","text":"SeqGaussSim(var₁=>param₁, var₂=>param₂, ...)\n\nA sequential Gaussian simulation solver.\n\nParameters\n\nvariogram - Variogram model (default to GaussianVariogram())\nmean      - Simple Kriging mean\ndegree    - Universal Kriging degree\ndrifts    - External Drift Kriging drift functions\n\nLatter options override former options. For example, by specifying drifts, the user is telling the algorithm to ignore degree and mean. If no option is specified, Ordinary Kriging is used by default with the variogram only.\n\nneighborhood - Neighborhood on which to search neighbors\nmaxneighbors - Maximum number of neighbors (default to 10)\npath         - Simulation path (default to RandomPath)\n\nFor each location in the simulation path, a maximum number of neighbors maxneighbors is used to fit a Gaussian distribution. The neighbors are searched according to a neighborhood.\n\n\n\n\n\n\n\n","category":"type"},{"location":"problems/#","page":"Problems","title":"Problems","text":"CookieCutter","category":"page"},{"location":"problems/#GeoStatsBase.CookieCutter","page":"Problems","title":"GeoStatsBase.CookieCutter","text":"CookieCutter(master, others)\n\nA cookie-cutter simulation solver.\n\nParameters\n\nmaster - Master simulation solver (a.k.a. facies solver)\nothers - A list of pairs mapping categories to solvers\n\nExamples\n\nSimulate lithology facies with image quilting and fill property with direct Gaussian simulation:\n\njulia> fsolver  = ImgQuilt(:facies => (TI=Strebelle, template=(30,30,1)))\njulia> psolver₀ = DirectGaussSim(:property => (variogram=SphericalVariogram(range=10.),))\njulia> psolver₁ = DirectGaussSim(:property => (variogram=SphericalVariogram(range=20.),))\njulia> solver   = CookieCutter(fsolver, [0 => psolver₀, 1 => psolver₁])\n\n\n\n\n\n","category":"type"},{"location":"problems/#Learning-solvers-1","page":"Problems","title":"Learning solvers","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"PointwiseLearn","category":"page"},{"location":"problems/#GeoStatsBase.PointwiseLearn","page":"Problems","title":"GeoStatsBase.PointwiseLearn","text":"PointwiseLearn(model)\n\nA learning solver that converts spatial data to a tabular format with features (and possibly labels) for each point, and then solves the problem with statistical learning model.\n\nParameters\n\nmodel - Learning model (e.g. SVM, Logistic Regression, K-means)\n\nNotes\n\nAny model implementing the MLJModelInterface.jl can be used in pointwise learning. Please refer to the MLJ documentation for a list of available models.\n\n\n\n\n\n","category":"type"},{"location":"empirical_variograms/#Empirical-variograms-1","page":"Empirical variograms","title":"Empirical variograms","text":"","category":"section"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"An empirical variogram has the form:","category":"page"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"newcommandxboldsymbolx\nhatgamma(h) = frac12N(h) sum_(ij) in N(h) (z_i - z_j)^2","category":"page"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"where N(h) = left(ij) mid x_i - x_j = hright is the set of pairs of locations at a distance h and N(h) is the cardinality of the set. Empirical variograms can be estimated using general distance functions. These can be used in order to for example:","category":"page"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"Model anisotropy (e.g. ellipsoid distance)\nPerform geostatistical simulation on spherical coordinate systems (e.g. haversine distance)","category":"page"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"Please see Distances.jl for a complete list of options.","category":"page"},{"location":"empirical_variograms/#Omnidirectional-1","page":"Empirical variograms","title":"Omnidirectional","text":"","category":"section"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"EmpiricalVariogram","category":"page"},{"location":"empirical_variograms/#Variography.EmpiricalVariogram","page":"Empirical variograms","title":"Variography.EmpiricalVariogram","text":"EmpiricalVariogram(sdata, var₁, var₂=var₁; [optional parameters])\n\nComputes the empirical (a.k.a. experimental) omnidirectional (cross-)variogram for variables var₁ and var₂ stored in spatial data sdata.\n\nEmpiricalVariogram(partition, var₁, var₂=var₁; [optional parameters])\n\nAlternatively, compute the (cross-)variogram on a partition of the data.\n\nParameters\n\nnlags    - number of lags (default to 20)\nmaxlag   - maximum lag (default to half of maximum lag of data)\ndistance - custom distance function (default to Euclidean distance)\nalgo     - accumulation algorithm (default to :auto)\n\nAvailable algorithms:\n\n:full - loop over all pairs of points in the data\n:ball - loop over all points inside maximum lag ball\n:auto - heuristic based on maxlag and boundbox(sdata)\n\nAll implemented algorithms produce the exact same result. The :ball algorithm is considerably faster when the maximum lag is much smaller than the bounding box of the data.\n\nSee also: DirectionalVariogram\n\n\n\n\n\n","category":"type"},{"location":"empirical_variograms/#Directional-1","page":"Empirical variograms","title":"Directional","text":"","category":"section"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"DirectionalVariogram","category":"page"},{"location":"empirical_variograms/#Variography.DirectionalVariogram","page":"Empirical variograms","title":"Variography.DirectionalVariogram","text":"DirectionalVariogram(spatialdata, direction, var₁, var₂=var₁; [optional parameters])\n\nComputes the empirical (cross-)variogram for the variables var₁ and var₂ stored in spatialdata along a given direction.\n\nOptional parameters include the parameters for EmpiricalVariogram and the parameters for DirectionPartitioner.\n\nNotes\n\nA DirectionalVariogram is just a function that first partitions the spatialdata using a DirectionPartitioner and then passes the result to the corresponding EmpiricalVariogram constructor.\n\nSee also: EmpiricalVariogram, DirectionPartitioner\n\n\n\n\n\n","category":"function"},{"location":"empirical_variograms/#","page":"Empirical variograms","title":"Empirical variograms","text":"Variogram plane plots are also available, please see Plotting.","category":"page"},{"location":"plotting/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"GeoStats.jl is integrated with the Julia Plots.jl project. This means that many objects defined in the package can be plotted directly without data format conversions.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"For example, below we plot various theoretical variograms with the plot command from Plots.jl:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"using GeoStats\nusing Plots\ngr(size=(600,400)) # hide\n\nplot(GaussianVariogram(), maxlag=3., label=\"Gaussian\")\nplot!(ExponentialVariogram(), maxlag=3., label=\"Exponential\")\nplot!(SphericalVariogram(), maxlag=3., label=\"Spherical\")\nplot!(MaternVariogram(), maxlag=3., label=\"Matern\")\nsavefig(\"images/variograms.svg\") # hide","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"and various spatial domains:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(RegularGrid{Float64}(10,10,10))\nsavefig(\"images/regulargrid.svg\") # hide","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(PointSet(rand(3,10)))\nsavefig(\"images/pointset.svg\") # hide","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Besides plotting GeoStats.jl objects directly, a few other plots are provided for exploring spatial data.","category":"page"},{"location":"plotting/#hscatter-1","page":"Plotting","title":"hscatter","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"A hscatter plot between two variables var1 and var2 (possibly with var2 = var1) is a simple scatter plot in which the dots represent all ordered pairs of values of var1 and var2 at a given lag h.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"gr(size=(800,300)) # hide\nZ = [10sin(i/10) + j for i in 1:100, j in 1:200]\n\nΩ = RegularGridData{Float64}(OrderedDict(:Z=>Z))\n\nhscatter(sample(Ω, 500), :Z, lags=[0.,20.,50.])\nsavefig(\"images/hscatter.svg\") # hide","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/#varplane-1","page":"Plotting","title":"varplane","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"A variogram plane (i.e. varplane) plot is a visualization that displays a collection of directional variograms for all angles in a given plane for 2D or 3D spatial data.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"# horizontal plane ==> theta=0, phi=90\nvarplane(Ω, :Z, theta=0, phi=90)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"userguide/#User-guide-1","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"This guide provides an overview of a simple geostatistical workflow, which consists of three basic steps:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Manipulation of spatial data\nDefinition of geostatistical problem\nVisualization of problem solution","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"These steps are only shown to guide the reader, which is free to follow his/her own workflow.","category":"page"},{"location":"userguide/#Manipulating-data-1","page":"User guide","title":"Manipulating data","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"The workflow starts with the creation of spatial data objects, which can be loaded from disk or derived from other Julia variables. For example, given a Julia array (or image), which is not attached to any particular coordinate system:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"using Plots\ngr(format=:svg) # hide\n\nZ = [10sin(i/10) + j for i in 1:100, j in 1:200]\n\nheatmap(Z, c=:bluesreds)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"we can georeference the image as RegularGridData:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"using GeoStats\n\nΩ = RegularGridData{Float64}(OrderedDict(:Z=>Z))","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"The origin and spacing of samples in the regular grid can be specified in the constructor:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"RegularGridData(OrderedDict(:Z=>Z), (1.,1.), (10.,10.))","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"and different spatial data types have different constructor options (see Data for more options).","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"We plot the spatial data and note a few differences compared to the image plot shown above:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"plot(Ω)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"First, we note that the image was rotated to match the first index i of the array with the horizontal \"x\" axis, and the second index j of the array with the vertical \"y\" axis. Second, we note that the image was stretched to reflect the real 100x200 size of the regular grid data.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Each sample in the spatial data object has a coordinate, which is calculated on demand for a given list of locations (i.e. spatial indices):","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"coordinates(Ω, 1:3)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"In-place versions exist to avoid unnecessary memory allocations.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"All coordinates are retrieved as a ndims x npoints matrix when we do not specify the spatial indices:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"coordinates(Ω)","category":"page"},{"location":"userguide/#Tabular-access-1","page":"User guide","title":"Tabular access","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Spatial data types implement the Tables.jl interface, which means that they can be accessed as if they were tables with samples in the rows and variables in the columns:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ω[1:3,:Z]","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"In this case, the coordinates of the samples are lost. To reconstruct a spatial data object, we need to save the spatial indices that were used to index the table:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"zvals = Ω[1:3,:Z]\ncoord = coordinates(Ω, 1:3)\n\nPointSetData(OrderedDict(:Z=>zvals), coord)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"To recover the original Julia array behind a spatial data object, we can index the data with the variable name. In this case, the size of the array (i.e. 100x200) is preserved:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ω[:Z]","category":"page"},{"location":"userguide/#Spatial-views-1","page":"User guide","title":"Spatial views","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Spatial data types can be viewed at a subset of locations without unnecessary memory allocations. Spatial views do not preserve the spatial regularity of the data in general.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"By plotting a view of the first 10 lines of our regular grid data, we obtain a general PointSetData as opposed to a RegularGridData:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ωᵥ = view(Ω, 1:10*100)\nplot(Ωᵥ)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"We plot a random view of the grid to emphasize that views do not preserve spatial regularity:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"inds = rand(1:npoints(Ω), 100)\nplot(view(Ω, inds))","category":"page"},{"location":"userguide/#Data-partitions-1","page":"User guide","title":"Data partitions","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Spatial data objects can be partitioned with various efficient methods. To demonstrate the operation, we partition our spatial data view into balls of given radius:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Π = partition(Ωᵥ, BallPartitioner(5.))\nplot(Π)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"or, alternatively, into two halfspaces:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Π = partition(Ωᵥ, BisectFractionPartitioner((1.,1.), 0.5))\nplot(Π)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Spatial partitions are (lazy) iterators of spatial views, which are useful in many contexts as it will be shown in the next section of the user guide. To access a subset of a partition, we use index notation:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"plot(Π[1])","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"plot(Π[2])","category":"page"},{"location":"userguide/#Defining-problems-1","page":"User guide","title":"Defining problems","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Having defined the spatial data objects, we proceed and define the geostatistical problem to be solved. In this guide, we illustrate geostatistical learning. For other types of geostatistical problems, please check the Problems section of the documentation.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Let's assume that we have spatial data with some variable that we want to predict in a supervised learning setting. We load the data from a CSV file, and inspect the available columns:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"using CSV\n\ndf = CSV.read(\"data/agriculture.csv\")\n\nfirst(df, 5)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Columns band1, ..., band4 represent four satellite bands for different locations (x,y) in this spatial region. The column crop has the crop type for each location that was labeled manually with the purpose of training a learning model.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Because the labels are categorical variables, we need to inform the framework the correct categorical type:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"using CategoricalArrays\n\ndf.crop = categorical(df.crop)\n\nfirst(df, 5)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"We can now georeference the data as a GeoDataFrame and plot some of the spatial variables:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ω = GeoDataFrame(df, [:x,:y])\n\ngr(format=:png) # hide\nplot(Ω, variables=[:band4,:crop], ms=0.2, mc=:viridis, size=(800,400))","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Similar to a generic statistical learning workflow, we split the data into \"train\" and \"test\" sets. The main difference here is that our spatial split function accepts a separating plane specified by its normal direction (1,-1):","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ωs, Ωt = split(Ω, 0.2, (1.,-1.))\n\nplot(domain(Ωs), ms=0.2)\nplot!(domain(Ωt), ms=0.2, mc=:green)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"We can visualize the domain of the \"train\" (or source) set Ωs in black, and the domain of the \"test\" (or target) set Ωt in green. We reserved 20% of the samples to Ωs and 80% to Ωt.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Let's define the learning task and the geostatistical learning problem. We want to predict the crop type based on the four satellite bands. We will train the model in Ωs where labels are available, and apply it to Ωt, which is our target:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"features = [:band1,:band2,:band3,:band4]\nlabel    = :crop\n\ntask = ClassificationTask(features, label)\n\nproblem = LearningProblem(Ωs, Ωt, task)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"GeoStats.jl is integrated with the MLJ.jl project, which means that we can solve geostatistical learning problems with any classical learning model:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"using MLJ\n\n@load DecisionTreeClassifier\n\nmodel = DecisionTreeClassifier()\n\nsolver = PointwiseLearn(model)","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"In this example, we selected a PointwiseLearn strategy to solve the geostatistical learning problem. This strategy consists of applying the learning model pointwise for every point in the spatial data:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ω̂t = solve(problem, solver)","category":"page"},{"location":"userguide/#Plotting-solutions-1","page":"User guide","title":"Plotting solutions","text":"","category":"section"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"First, we note that the solution to a geostatistical learning problem is a spatial data object. We can inspect it with the same methods already described:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Ω̂t[1:5,:crop]","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"This also means that we can plot the solution directly, side by side with the true label in this synthetic example:","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"p̂ = plot(Ω̂t, ms=0.2, mc=:viridis, title=\"crop (prediction)\")\np = plot(Ωt, variables=[:crop], ms=0.2, mc=:viridis)\n\nplot(p̂, p, size=(800,400))","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"Visually, the learning model has succeeded predicting the crop. We can also estimate the generalization error of the geostatistical solver with spatial validation methods such as block cross-validation and leave-ball-out, but these methods deserve a separate tutorial.","category":"page"},{"location":"userguide/#","page":"User guide","title":"User guide","text":"With this example we conclude the user guide. To get familiar with other features of GeoStats.jl, please check the tutorials and the reference guide.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: GeoStatsLogo)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: Stable Documentation) (Image: Latest Documentation) (Image: License File)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Gitter) (Image: JOSS) (Image: DOI)","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In many fields of science, such as mining engineering, hydrogeology, petroleum engineering, and environmental sciences, traditional statistical theories fail to provide unbiased estimates of resources due to the presence of spatial correlation. Geostatistics (a.k.a. spatial statistics) is the branch of statistics developed to overcome this limitation. Particularly, it is the branch that takes spatial coordinates of data into account.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"GeoStats.jl is an attempt to bring together bleeding-edge research in the geostatistics community into a comprehensive framework for spatial statistics, as well as to empower researchers and practioners with a toolkit for fast assessment of different modeling approaches.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The design of this project is the result of many years developing geostatistical software. I hope that it can serve to promote more collaboration between geostatisticians around the globe and to standardize this incredible science. If you would like to help support the project, please star the repository on GitHub and share it with your colleagues. If you are a developer, please check the Developer guide.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add GeoStats","category":"page"},{"location":"#Project-organization-1","page":"Home","title":"Project organization","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The project is split into various packages:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Package Description\nGeoStats.jl Main package reexporting full stack of packages for geostatistics.\nVariography.jl Variogram estimation and modeling, and related tools.\nKrigingEstimators.jl High-performance implementations of Kriging estimators.\nPointPatterns.jl Spatial point pattern analysis and synthesis.\nGeoStatsImages.jl Training images for multiple-point geostatistical simulation.\nGslibIO.jl Utilities to read/write extended GSLIB files.\nGeoStatsBase.jl Base package containing problem and solution specifications (for developers).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The main package (i.e. GeoStats.jl) is self-contained, and provides the full stack of packages for high-performance geostatistics over arbitrary domains. Other packages like GeoStatsImages.jl can be installed from the list above for additional functionality.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Besides the packages above, the project is extended via solver packages, for which the links are listed in the README on GitHub. These solvers are implemented independently of the main package for different geostatistical problems.","category":"page"},{"location":"#Quick-example-1","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Below is a quick preview of a geostatistical estimation problem solved with a Kriging solver. Besides estimation, the framework implements various solvers for geostatistical simulation and geostatitistical learning problems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GeoStats\nusing Plots\ngr(size=(900,400)) # hide\n\n# define spatial data\nsdata = PointSetData(OrderedDict(:precipitation => [1.,0.,1.]), [(25.,25.),(50.,75.),(75.,50.)])\n\n# define spatial domain (e.g. regular grid, point set)\nsdomain = RegularGrid{Float64}(100, 100)\n\n# define estimation problem for any data column(s) (e.g. :precipitation)\nproblem = EstimationProblem(sdata, sdomain, :precipitation)\n\n# choose a solver from the list of solvers\nsolver = Kriging(\n  :precipitation => (variogram=GaussianVariogram(range=35.),)\n)\n\n# solve the problem\nsolution = solve(problem, solver)\n\n# plot the solution\ncontourf(solution, clabels=true)\npng(\"images/EstimationSolution.png\") # hide","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For the full example, please see the Tutorials section of the documentation.","category":"page"},{"location":"about/citing/#","page":"Citing","title":"Citing","text":"If you find GeoStats.jl useful in your work, please consider citing it:","category":"page"},{"location":"about/citing/#","page":"Citing","title":"Citing","text":"(Image: JOSS) (Image: DOI)","category":"page"},{"location":"about/citing/#","page":"Citing","title":"Citing","text":"@ARTICLE{Hoffimann2018,\n  title={GeoStats.jl – High-performance geostatistics in Julia},\n  author={Hoffimann, Júlio},\n  journal={Journal of Open Source Software},\n  publisher={The Open Journal},\n  volume={3},\n  pages={692},\n  number={24},\n  ISSN={2475-9066},\n  DOI={10.21105/joss.00692},\n  url={http://dx.doi.org/10.21105/joss.00692},\n  year={2018},\n  month={Apr}\n}","category":"page"}]
}
