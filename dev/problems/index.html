<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problems · GeoStats.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GeoStats.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../userguide/">User guide</a></li><li><a class="toctext" href="../tutorials/">Tutorials</a></li><li><span class="toctext">Reference guide</span><ul><li><a class="toctext" href="../data/">Data</a></li><li><a class="toctext" href="../domains/">Domains</a></li><li class="current"><a class="toctext" href>Problems</a><ul class="internal"><li><a class="toctext" href="#Estimation-problem-1">Estimation problem</a></li><li><a class="toctext" href="#Simulation-problem-1">Simulation problem</a></li><li><a class="toctext" href="#Learning-problem-1">Learning problem</a></li><li class="toplevel"><a class="toctext" href="#Built-in-solvers-1">Built-in solvers</a></li></ul></li><li><span class="toctext">Variography</span><ul><li><a class="toctext" href="../empirical_variograms/">Empirical variograms</a></li><li><a class="toctext" href="../theoretical_variograms/">Theoretical variograms</a></li><li><a class="toctext" href="../fitting_variograms/">Fitting variograms</a></li></ul></li><li><a class="toctext" href="../estimators/">Kriging estimators</a></li><li><a class="toctext" href="../comparisons/">Solver comparisons</a></li><li><a class="toctext" href="../operations/">Spatial operations</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li></ul></li><li><a class="toctext" href="../devguide/">Developer guide</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../about/community/">Community</a></li><li><a class="toctext" href="../about/license/">License</a></li><li><a class="toctext" href="../about/citing/">Citing</a></li></ul></li><li><a class="toctext" href="../links/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Reference guide</li><li><a href>Problems</a></li></ul><a class="edit-page" href="https://github.com/juliohm/GeoStats.jl/blob/master/docs/src/problems.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Problems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Problems-1" href="#Problems-1">Problems</a></h1><p>One of the greatest features of GeoStats.jl is the ability to define geostatistical problems independently of the solution strategy. This design allows researchers and practioners to perform <em>fair comparisons</em> between different solvers. It is perhaps the single most important contribution of this project.</p><p>If you are an experienced user of geostatistics or if you do research in the field, you know how hard it is to compare algorithms fairly. Often a new algorithm is proposed in the literature, and yet the task of comparing it with the state of the art is quite demanding. Even when a comparison is made by the author after a great amount of effort, it is inevitably biased.</p><p>Part of this issue is attributed to the fact that a formal definition of geostatistical problems is missing. The project provides solutions to three problems defined below.</p><h2><a class="nav-anchor" id="Estimation-problem-1" href="#Estimation-problem-1">Estimation problem</a></h2><p>An estimation problem in geostatitsics is a triplet:</p><ol><li>Spatial data (i.e. data with coordinates)</li><li>Spatial domain (e.g. regular grid, point collection)</li><li>Target variables (or variables to be estimated)</li></ol><p>Each of these components is constructed separately, and then grouped (no memory is copied) in an <code>EstimationProblem</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.EstimationProblem" href="#GeoStatsBase.EstimationProblem"><code>GeoStatsBase.EstimationProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EstimationProblem(spatialdata, domain, targetvars)</code></pre><p>A spatial estimation problem on a given <code>domain</code> in which the variables to be estimated are listed in <code>targetvars</code>. The data of the problem is stored in <code>spatialdata</code>.</p><p><strong>Examples</strong></p><p>Create an estimation problem for rainfall precipitation measurements:</p><pre><code class="language-julia">julia&gt; EstimationProblem(spatialdata, domain, :precipitation)</code></pre><p>Create an estimation problem for precipitation and CO₂:</p><pre><code class="language-julia">julia&gt; EstimationProblem(spatialdata, domain, (:precipitation,:CO₂))</code></pre></div></div></section><p>Please check <a href="../data/">Spatial data</a> and <a href="../domains/">Domains</a> for currently implemented data and domain types.</p><h2><a class="nav-anchor" id="Simulation-problem-1" href="#Simulation-problem-1">Simulation problem</a></h2><p>Likewise, a stochastic simulation problem in geostatistics is represented with the same triplet. However, the spatial data in this case is optional in order to accomodate the concept of conditional versus unconditional simulation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.SimulationProblem" href="#GeoStatsBase.SimulationProblem"><code>GeoStatsBase.SimulationProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimulationProblem(spatialdata, domain, targetvars, nreals)
SimulationProblem(domain, targetvars, nreals)</code></pre><p>A spatial simulation problem on a given <code>domain</code> in which the variables to be simulated are listed in <code>targetvars</code>.</p><p>For conditional simulation, the data of the problem is stored in <code>spatialdata</code>.</p><p>For unconditional simulation, a list of pairs <code>targetvars</code> must be provided mapping variable names to their types.</p><p>In both cases, a number <code>nreals</code> of realizations is requested.</p><p><strong>Examples</strong></p><p>Create a conditional simulation problem for porosity and permeability with 100 realizations:</p><pre><code class="language-julia">julia&gt; SimulationProblem(spatialdata, domain, (:porosity,:permeability), 100)</code></pre><p>Create an unconditional simulation problem for porosity and facies type with 100 realizations:</p><pre><code class="language-julia">julia&gt; SimulationProblem(domain, (:porosity =&gt; Float64, :facies =&gt; Int), 100)</code></pre><p><strong>Notes</strong></p><p>To check if a simulation problem has data (i.e. conditional vs. unconditional) use the <a href="#GeoStatsBase.hasdata"><code>hasdata</code></a> method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.hasdata" href="#GeoStatsBase.hasdata"><code>GeoStatsBase.hasdata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hasdata(problem)</code></pre><p>Return <code>true</code> if simulation <code>problem</code> has data.</p></div></div></section><h2><a class="nav-anchor" id="Learning-problem-1" href="#Learning-problem-1">Learning problem</a></h2><p>A geostatistical learning problem consists of a triplet:</p><ol><li>Source spatial data (e.g. with labels)</li><li>Target spatial data (e.g. without labels)</li><li>Learning task (e.g. classification)</li></ol><p>In this case, a learning model is trained with the source spatial data, and then used to perform the same task with the target spatial data.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.LearningProblem" href="#GeoStatsBase.LearningProblem"><code>GeoStatsBase.LearningProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LearningProblem(sourcedata, targetdata, task)</code></pre><p>A spatial learning problem with <code>sourcedata</code>, <code>targetdata</code>, and learning <code>task</code>.</p><p><strong>Examples</strong></p><p>Create a clustering problem based on a set of soil features:</p><pre><code class="language-julia">julia&gt; LearningProblem(sourcedata, targetdata,
                       ClusteringTask((:moisture,:mineral)))</code></pre></div></div></section><h1><a class="nav-anchor" id="Built-in-solvers-1" href="#Built-in-solvers-1">Built-in solvers</a></h1><p>Below is the list of solvers distributed with GeoStats.jl. For more solvers, please check the <a href="https://github.com/juliohm/GeoStats.jl#problems-and-solvers">project page on GitHub</a> where a table is provided with links to accompanying repositories.</p><h3><a class="nav-anchor" id="Estimation-solvers-1" href="#Estimation-solvers-1">Estimation solvers</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrigingEstimators.Kriging" href="#KrigingEstimators.Kriging"><code>KrigingEstimators.Kriging</code></a> — <span class="docstring-category">Type</span>.</div><div><div><div><pre><code class="language-julia">Kriging(var₁=&gt;param₁, var₂=&gt;param₂, ...)</code></pre><p>A polyalgorithm Kriging estimation solver.</p><p>Each pair <code>var=&gt;param</code> specifies the <code>KrigingParam</code> <code>param</code> for the Kriging variable <code>var</code>. In order to avoid boilerplate code, the constructor expects pairs of <code>Symbol</code> and <code>NamedTuple</code> instead.</p><p><strong>Parameters</strong></p><ul><li><code>variogram</code> - Variogram model (default to <code>GaussianVariogram()</code>)</li><li><code>mean</code>      - Simple Kriging mean</li><li><code>degree</code>    - Universal Kriging degree</li><li><code>drifts</code>    - External Drift Kriging drift functions</li></ul><p>Latter options override former options. For example, by specifying <code>drifts</code>, the user is telling the algorithm to ignore <code>degree</code> and <code>mean</code>. If no option is specified, Ordinary Kriging is used by default with the <code>variogram</code> only.</p><ul><li><code>maxneighbors</code> - Maximum number of neighbors (default to <code>nothing</code>)</li><li><code>neighborhood</code> - Search neighborhood (default to <code>nothing</code>)</li><li><code>distance</code>     - Distance used to find nearest neighbors (default to <code>Euclidean()</code>)</li></ul><p>The <code>maxneighbors</code> option can be used to perform approximate Kriging with a subset of data points per estimation location. Two neighborhood search methods are available depending on the value of <code>neighborhood</code>:</p><ul><li><p>If a <code>neighborhood</code> is provided, local Kriging is performed by sliding the <code>neighborhood</code> in the domain.</p></li><li><p>If <code>neighborhood</code> is not provided, the Kriging system is built using <code>maxneighbors</code> nearest neighbors according to a <code>distance</code>.</p></li></ul><p><strong>Examples</strong></p><p>Solve the variable <code>:var₁</code> with Simple Kriging by specifying the <code>mean</code>, and the variable <code>:var₂</code> with Universal Kriging by specifying the <code>degree</code> and the <code>variogram</code> model.</p><pre><code class="language-julia">julia&gt; Kriging(
  :var₁ =&gt; (mean=1.,),
  :var₂ =&gt; (degree=1, variogram=SphericalVariogram(range=20.))
)</code></pre><p>Solve all variables of the problem with the default parameters (i.e. Ordinary Kriging with unit Gaussian variogram):</p><pre><code class="language-julia">julia&gt; Kriging()</code></pre></div></div></div></section><h3><a class="nav-anchor" id="Simulation-solvers-1" href="#Simulation-solvers-1">Simulation solvers</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrigingEstimators.SeqGaussSim" href="#KrigingEstimators.SeqGaussSim"><code>KrigingEstimators.SeqGaussSim</code></a> — <span class="docstring-category">Type</span>.</div><div><div><div><pre><code class="language-julia">SeqGaussSim(var₁=&gt;param₁, var₂=&gt;param₂, ...)</code></pre><p>A sequential Gaussian simulation solver.</p><p><strong>Parameters</strong></p><ul><li><code>variogram</code> - Variogram model (default to <code>GaussianVariogram()</code>)</li><li><code>mean</code>      - Simple Kriging mean</li><li><code>degree</code>    - Universal Kriging degree</li><li><code>drifts</code>    - External Drift Kriging drift functions</li></ul><p>Latter options override former options. For example, by specifying <code>drifts</code>, the user is telling the algorithm to ignore <code>degree</code> and <code>mean</code>. If no option is specified, Ordinary Kriging is used by default with the <code>variogram</code> only.</p><ul><li><code>neighborhood</code> - Neighborhood on which to search neighbors</li><li><code>maxneighbors</code> - Maximum number of neighbors (default to 10)</li><li><code>path</code>         - Simulation path (default to <code>RandomPath</code>)</li></ul><p>For each location in the simulation <code>path</code>, a maximum number of neighbors <code>maxneighbors</code> is used to fit a Gaussian distribution. The neighbors are searched according to a <code>neighborhood</code>.</p></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.CookieCutter" href="#GeoStatsBase.CookieCutter"><code>GeoStatsBase.CookieCutter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CookieCutter(master, others)</code></pre><p>A cookie-cutter simulation solver.</p><p><strong>Parameters</strong></p><ul><li><code>master</code> - Master simulation solver (a.k.a. facies solver)</li><li><code>others</code> - A list of pairs mapping categories to solvers</li></ul><p><strong>Examples</strong></p><p>Simulate lithology facies with image quilting and fill property with direct Gaussian simulation:</p><pre><code class="language-julia">julia&gt; fsolver  = ImgQuilt(:facies =&gt; (TI=Strebelle, template=(30,30,1)))
julia&gt; psolver₀ = DirectGaussSim(:property =&gt; (variogram=SphericalVariogram(range=10.),))
julia&gt; psolver₁ = DirectGaussSim(:property =&gt; (variogram=SphericalVariogram(range=20.),))
julia&gt; solver   = CookieCutter(fsolver, [0 =&gt; psolver₀, 1 =&gt; psolver₁])</code></pre></div></div></section><h3><a class="nav-anchor" id="Learning-solvers-1" href="#Learning-solvers-1">Learning solvers</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeoStatsBase.PointwiseLearn" href="#GeoStatsBase.PointwiseLearn"><code>GeoStatsBase.PointwiseLearn</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointwiseLearn(model)</code></pre><p>A learning solver that converts spatial data to a tabular format with features (and possibly labels) for each point, and then solves the problem with statistical learning <code>model</code>.</p><p><strong>Parameters</strong></p><ul><li><code>model</code> - Learning model (e.g. SVM, Logistic Regression, K-means)</li></ul><p><strong>Notes</strong></p><p>Any model implementing the <code>MLJBase</code> interface can be used in pointwise learning. Please refer to the <code>MLJ</code> documentation for a list of available models.</p></div></div></section><footer><hr/><a class="previous" href="../domains/"><span class="direction">Previous</span><span class="title">Domains</span></a><a class="next" href="../empirical_variograms/"><span class="direction">Next</span><span class="title">Empirical variograms</span></a></footer></article></body></html>
